import * as React from 'react';
import { HorizontalAlignment_$type } from "igniteui-react-core";
import { UnknownValuePlotting_$type } from "igniteui-react-core";
import { TrendLineType_$type } from "igniteui-react-core";
import { IgrChartSeriesEventArgs } from './igr-chart-series-event-args';
import { arrayFindByName, brushToString, stringToBrush, toBrushCollection, fromBrushCollection, fromRect, toRect, ensureBool, ensureEnum, isValidProp, getModifiedProps, toSpinal, initializePropertiesFromCss, NamePatcher } from "igniteui-react-core";
import { MarkerType_$type } from "./MarkerType";
import { delegateCombine, delegateRemove } from "igniteui-react-core";
import { IgrDomainChartSeriesPointerEventArgs } from './igr-domain-chart-series-pointer-event-args';
import { MarkerTypeCollection as MarkerTypeCollection_internal } from './MarkerTypeCollection';
import { IgrMarkerTypeCollection } from './igr-marker-type-collection';
import { SyncableObservableCollection$1 } from "igniteui-react-core";
import { ToolTipType_$type } from "./ToolTipType";
import { CrosshairsDisplayMode_$type } from "./CrosshairsDisplayMode";
import { IgrCalloutStyleUpdatingEventArgs } from "./igr-callout-style-updating-event-args";
import { ComputedPlotAreaMarginMode_$type } from './ComputedPlotAreaMarginMode';
import { SeriesHighlightingMode_$type } from './SeriesHighlightingMode';
import { SeriesHighlightingBehavior_$type } from './SeriesHighlightingBehavior';
import { LegendHighlightingMode_$type } from './LegendHighlightingMode';
import { SeriesOutlineMode_$type } from './SeriesOutlineMode';
import { MarkerOutlineMode_$type } from './MarkerOutlineMode';
import { MarkerFillMode_$type } from './MarkerFillMode';
import { MarkerAutomaticBehavior_$type } from './MarkerAutomaticBehavior';
import { LegendItemBadgeMode_$type } from "igniteui-react-core";
import { LegendItemBadgeShape_$type } from "igniteui-react-core";
import { DataAbbreviationMode_$type } from "igniteui-react-core";
import { DataLegendValueMode_$type } from "igniteui-react-core";
import { DataLegendHeaderDateMode_$type } from "igniteui-react-core";
import { DataLegendHeaderTimeMode_$type } from "igniteui-react-core";
import { DataLegendUnitsMode_$type } from "igniteui-react-core";
import { DataLegendLabelMode_$type } from "igniteui-react-core";
import { DataLegendSummaryType_$type } from "igniteui-react-core";
import { Thickness } from "igniteui-react-core";
import { FontInfo } from "igniteui-react-core";
import { SeriesPlotAreaMarginHorizontalMode_$type } from './SeriesPlotAreaMarginHorizontalMode';
import { SeriesPlotAreaMarginVerticalMode_$type } from './SeriesPlotAreaMarginVerticalMode';
import { IgrCalloutPlacementPositionsCollection } from './igr-callout-placement-positions-collection';
import { CalloutPlacementPositions_$type } from './CalloutPlacementPositions';
import { SeriesViewerScrollbarMode_$type } from './SeriesViewerScrollbarMode';
import { SeriesViewerHorizontalScrollbarPosition_$type } from './SeriesViewerHorizontalScrollbarPosition';
import { SeriesViewerVerticalScrollbarPosition_$type } from './SeriesViewerVerticalScrollbarPosition';
import { IgrCalloutRenderStyleUpdatingEventArgs } from './igr-callout-render-style-updating-event-args';
import { CalloutPlacementPositionsCollection as CalloutPlacementPositionsCollection_internal } from './CalloutPlacementPositionsCollection';
import { DataToolTipLayerGroupingMode_$type } from "igniteui-react-core";
import { DataTooltipGroupedPositionX_$type } from "igniteui-react-core";
import { DataTooltipGroupedPositionY_$type } from "igniteui-react-core";
export class IgrDomainChart extends React.Component {
    constructor(props) {
        super(props);
        this._calloutsDataSource = null;
        this._markerTypes = null;
        this._calloutsAllowedPositions = null;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._seriesAdded = null;
        this._seriesAdded_wrapped = null;
        this._seriesRemoved = null;
        this._seriesRemoved_wrapped = null;
        this._seriesPointerEnter = null;
        this._seriesPointerEnter_wrapped = null;
        this._seriesPointerLeave = null;
        this._seriesPointerLeave_wrapped = null;
        this._seriesPointerMove = null;
        this._seriesPointerMove_wrapped = null;
        this._seriesPointerDown = null;
        this._seriesPointerDown_wrapped = null;
        this._seriesPointerUp = null;
        this._seriesPointerUp_wrapped = null;
        this._calloutStyleUpdating = null;
        this._calloutStyleUpdating_wrapped = null;
        this._calloutRenderStyleUpdating = null;
        this._calloutRenderStyleUpdating_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    createImplementation() {
        return null;
    }
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    componentDidMount() {
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        return null;
    }
    /**
    * Sets or gets the template reference to use for tooltips for all the series.
    *
    *
    */
    get tooltipTemplate() {
        return this.i.tooltipTemplate;
    }
    set tooltipTemplate(v) {
        this.i.tooltipTemplate = v;
    }
    /**
    * Sets or gets the template references to use for tooltips for all the series, in order.
    *
    *
    */
    get tooltipTemplates() {
        let ret = [];
        if (this.i.tooltipTemplates) {
            for (let ii = 0; ii < this.i.tooltipTemplates.count; ii++) {
                ret.push(this.i.tooltipTemplates.item(ii));
            }
        }
        return ret;
    }
    set tooltipTemplates(v) {
        this.i.tooltipTemplates.clear();
        if (v) {
            for (let ii = 0; ii < v.length; ii++) {
                this.i.tooltipTemplates.add(v[ii]);
            }
        }
    }
    get legend() {
        if (this.i.legend != null)
            return this.i.legend.externalObject;
    }
    set legend(v) {
        if (v != undefined && v != null)
            this.i.legend = v.i;
    }
    set calloutsDataSource(value) {
        this._calloutsDataSource = value;
        this.bindCalloutsData();
    }
    get calloutsDataSource() {
        return this._calloutsDataSource;
    }
    bindCalloutsData() {
        if (this.i != null && this.i !== undefined) {
            this.i.calloutsItemsSource = this._calloutsDataSource;
        }
    }
    /**
 * Gets or sets the scaling value used to affect the pixel density of the control.
 * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
 * to appear blurry.
*/
    get pixelScalingRatio() {
        return this.i.hi;
    }
    set pixelScalingRatio(v) {
        this.i.hi = +v;
    }
    /**
     * Gets or sets the left margin of chart title
    *
    *  Use `titleLeftMargin` property for the left margin of chart title.
    *
    * ```ts
    * this.chart.titleLeftMargin = 10;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart dataSource={this.state.data}
    *                    titleLeftMargin={20}>
    *  </IgrCategoryChart>
    * ```
    */
    get titleLeftMargin() {
        return this.i.hv;
    }
    set titleLeftMargin(v) {
        this.i.hv = +v;
    }
    /**
     * Gets or sets the right margin of chart title
    *
    *  Use `titleLeftMargin` property for the right margin of chart title.
    *
    * ```ts
    * this.chart.titleRightMargin = 10;
    * ```
    *
    * ```ts
    * <IgrCategoryChart
    * 				dataSource={this.state.data}
    *                 titleRightMargin = 10>
    *  </IgrCategoryChart>
    * ```
    */
    get titleRightMargin() {
        return this.i.hw;
    }
    set titleRightMargin(v) {
        this.i.hw = +v;
    }
    /**
     * Gets or sets the top margin of chart title
    *
    *  Use `titleTopMargin` property for the top margin of chart title.
    *
    * ```ts
    * this.chart.titleTopMargin = 10;
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                titleTopMargin={10} />
    * ```
    */
    get titleTopMargin() {
        return this.i.hx;
    }
    set titleTopMargin(v) {
        this.i.hx = +v;
    }
    /**
     * Gets or sets the bottom margin of chart title
    *
    *  Use `titleBottomMargin` property for the bottom margin of chart title.
    *
    * ```ts
    *  this.chart.titleBottomMargin = 5;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitle= "CategoryChart Subtitle"
    * 	subtitleAlignment="Right"
    * 	titleBottomMargin={5}/>
    * ```
    */
    get titleBottomMargin() {
        return this.i.hu;
    }
    set titleBottomMargin(v) {
        this.i.hu = +v;
    }
    /**
     * Gets or sets the left margin of chart subtitle
    *
    * Use `subtitleLeftMargin` property for the left margin of chart subtitle.
    *
    * ```ts
    * this.chart.subtitleLeftMargin = 20 ;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitle= "CategoryChart Subtitle"
    * 	subtitleLeftMargin= {20}/>
    * ```
    */
    get subtitleLeftMargin() {
        return this.i.hq;
    }
    set subtitleLeftMargin(v) {
        this.i.hq = +v;
    }
    /**
     * Gets or sets the top margin of chart subtitle
    *
    * Use `subtitleTopMargin` property for the top margin of chart subtitle.
    *
    * ```ts
    * this.chart.subtitleTopMargin = 10;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitle= "CategoryChart Subtitle"
    * 	subtitleTopMargin= {10}/>
    * ```
    */
    get subtitleTopMargin() {
        return this.i.hs;
    }
    set subtitleTopMargin(v) {
        this.i.hs = +v;
    }
    /**
     * Gets or sets the right margin of chart subtitle
    *
    * Use `subtitleRightMargin` property for the right margin of chart subtitle.
    *
    * ```ts
    *  this.chart.subtitleRightMargin = 20 ;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitle= "CategoryChart Subtitle"
    * 	subtitleAlignment="Right"
    * 	subtitleRightMargin ={20}/>
    * ```
    */
    get subtitleRightMargin() {
        return this.i.hr;
    }
    set subtitleRightMargin(v) {
        this.i.hr = +v;
    }
    /**
     * Gets or sets the bottom margin of chart subtitle
    *
    * Use `subtitleBottomMargin` property for the bottom margin of chart subtitle.
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitle= "CategoryChart Subtitle"
    * 	subtitleBottomMargin= {10}/>
    * ```
    *
    * ```ts
    * this.chart.subtitleBottomMargin = 10 ;
    * ```
    */
    get subtitleBottomMargin() {
        return this.i.hp;
    }
    set subtitleBottomMargin(v) {
        this.i.hp = +v;
    }
    /**
     * Gets or sets color of chart subtitle
    *
    * Use `subtitleTextColor` property to color the subtitle.
    *
    * ```ts
    * this.chart.subtitleTextColor = "#ff0000" ;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitle= "CategoryChart Subtitle"
    * 	subtitleTextColor="#ff0000"/>
    * ```
    */
    get subtitleTextColor() {
        return brushToString(this.i.s0);
    }
    set subtitleTextColor(v) {
        this.i.s0 = stringToBrush(v);
    }
    /**
     * Gets or sets color of chart title
    *
    *  Use `titleTextColor` property to color the chart title
    *
    * ```ts
    *  this.chart.titleTextColor="red" ;
    * ```
    *
    * ```ts
    * <IgrCategoryChart
    * 		dataSource={this.state.data}
    * 		width="700px"
    * 		height="500px"
    * 		xAxisTitle="Countries"
    * 		titleTextColor="Red" />
    *
    * ```
    */
    get titleTextColor() {
        return brushToString(this.i.s1);
    }
    set titleTextColor(v) {
        this.i.s1 = stringToBrush(v);
    }
    /**
     * Gets or sets the left margin of the chart content.
    *
    * Use the 'leftMargin' property for the left margin of the chart content.
    *
    * ```ts
    *  this.chart.leftMargin = 20;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart dataSource={this.state.data}
    *                    leftMargin= {20}/>
    * ```
    */
    get leftMargin() {
        return this.i.hf;
    }
    set leftMargin(v) {
        this.i.hf = +v;
    }
    /**
     * Gets or sets the top margin of the chart content.
    *
    * Use `topMargin` property for the margin of the chart content.
    *
    * ```ts
    * this.chart.topMargin=20;
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                topMargin={10} />
    * ```
    */
    get topMargin() {
        return this.i.hy;
    }
    set topMargin(v) {
        this.i.hy = +v;
    }
    /**
     * Gets or sets the right margin of the chart content.
    *
    * Use `rightMargin` property for the right margin of the chart content.
    *
    * ```ts
    *   this.chart.rightMargin = 20 ;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	rightMargin= {4}/>
    * ```
    */
    get rightMargin() {
        return this.i.ho;
    }
    set rightMargin(v) {
        this.i.ho = +v;
    }
    /**
     * Gets or sets the bottom margin around the chart content.
    *
    * Use the `bottomMargin` property for the bottom margin around the chart content.
    *
    * ```ts
    * this.chart.bottomMargin=20;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart dataSource={this.state.data}
    *                    bottomMargin= 20 />
    * ```
    */
    get bottomMargin() {
        return this.i.g2;
    }
    set bottomMargin(v) {
        this.i.g2 = +v;
    }
    /**
     * Gets or sets the duration used for animating series plots when the data is changing
    *
    * Use the `transitionDuration` property to animating between data values.
    *
    * ```ts
    * this.chart.transitionDuratio= 500;
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                transitionDuratio={500} />
    * ```
    */
    get transitionDuration() {
        return this.i.iq;
    }
    set transitionDuration(v) {
        this.i.iq = +v;
    }
    /**
     * Gets or sets the easing function used for animating series plots when the data is changing.
     * This can be set to one of the known values "linear" or "cubic," or it can be set to an easing function which takes a single numeric parameter and returns a number.
    *
    * The 'transitionInEasingFunction' property used for easing function for animating series plots when the chart is loading into view.
    *
    * ```ts
    * this.chart.transitionInEasingFunction=  this.cubicFunc;
    *
    * cubicFunc(time: number) : number
    *   {
    *     return time;
    *   }
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                transitionInEasingFunction="cubic" />
    * ```
    */
    get transitionEasingFunction() {
        return this.i.c8;
    }
    set transitionEasingFunction(v) {
        this.i.c8 = v;
    }
    /**
     * Gets or sets CSS font property for the chart subtitle
    *
    * Use `subtitleTextStyle` property for the CSS font of the chart subtitle.
    *
    * ```ts
    * this.chart.subtitleTextStyle= "16pt Verdona";
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitleTextStyle="16pt Verdona"/>
    * ```
    */
    get subtitleTextStyle() {
        return this.i.od;
    }
    set subtitleTextStyle(v) {
        this.i.od = v;
    }
    /**
     * Gets or sets CSS font property for the chart title
    *
    * Use `titleTextStyle` property for the CSS font property of the chart title
    *
    * ```ts
    * this.chart.xAxisTitleTextStyle = "24pt Verdona";
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                 width="700px"
    *                 height="500px"
    *                 xAxisTitle="Countries"
    *                 xAxisTitleTextColor="gray"
    *                 xAxisTitleTextStyle="12pt Verdana"
    *                 xAxisTitleAngle={0}
    *                 yAxisTitle="Trillions of Watt-hours (TWh)"
    *                 yAxisTitleTextStyle="12pt Verdana"
    *                 yAxisTitleTextColor="gray"
    *                 yAxisTitleAngle={90}
    *                 yAxisTitleLeftMargin={5}>
    *  </IgrCategoryChart>
    * ```
    */
    get titleTextStyle() {
        return this.i.oo;
    }
    set titleTextStyle(v) {
        this.i.oo = v;
    }
    get dataToolTipGroupingMode() {
        return this.i.bc;
    }
    set dataToolTipGroupingMode(v) {
        this.i.bc = ensureEnum(DataToolTipLayerGroupingMode_$type, v);
    }
    /**
     * Gets or sets the offset of the tooltip layer on the X axis.
    */
    get dataToolTipPositionOffsetX() {
        return this.i.g6;
    }
    set dataToolTipPositionOffsetX(v) {
        this.i.g6 = +v;
    }
    /**
     * Gets or sets the offset of the tooltip layer on the Y axis.
    */
    get dataToolTipPositionOffsetY() {
        return this.i.g7;
    }
    set dataToolTipPositionOffsetY(v) {
        this.i.g7 = +v;
    }
    /**
     * Gets or sets the offset of the tooltip layer on the X axis.
    */
    get dataToolTipDefaultPositionOffsetX() {
        return this.i.g4;
    }
    set dataToolTipDefaultPositionOffsetX(v) {
        this.i.g4 = +v;
    }
    /**
     * Gets or sets the offset of the tooltip layer on the Y axis.
    */
    get dataToolTipDefaultPositionOffsetY() {
        return this.i.g5;
    }
    set dataToolTipDefaultPositionOffsetY(v) {
        this.i.g5 = +v;
    }
    /**
     * Gets or sets the tooltip position mode on the X axis for grouped series.
    */
    get dataToolTipGroupedPositionModeX() {
        return this.i.a8;
    }
    set dataToolTipGroupedPositionModeX(v) {
        this.i.a8 = ensureEnum(DataTooltipGroupedPositionX_$type, v);
    }
    /**
     * Gets or sets the tooltip position mode on the Y axis for grouped series.
    */
    get dataToolTipGroupedPositionModeY() {
        return this.i.ba;
    }
    set dataToolTipGroupedPositionModeY(v) {
        this.i.ba = ensureEnum(DataTooltipGroupedPositionY_$type, v);
    }
    /**
     * Gets or sets whether the data legend should update when the series data is mutated.
    */
    get dataToolTipShouldUpdateWhenSeriesDataChanges() {
        return this.i.eo;
    }
    set dataToolTipShouldUpdateWhenSeriesDataChanges(v) {
        this.i.eo = ensureBool(v);
    }
    /**
     * Gets or sets indexes or names of series to include in displaying in the data legend, e.g. "0, 1"
    */
    get dataToolTipIncludedSeries() {
        return this.i.m;
    }
    set dataToolTipIncludedSeries(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.m = v;
    }
    /**
     * Gets or sets indexes or names of series to exclude from displaying in the data legend, e.g. "0, 1"
     * The ExcludedSeries property takes precedences over values of IncludedSeries property
    */
    get dataToolTipExcludedSeries() {
        return this.i.j;
    }
    set dataToolTipExcludedSeries(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.j = v;
    }
    /**
     * Gets or sets names of data columns or their labels to include in displaying in the data legend, e.g. "High, Low" or "H, L"
     * The ExcludedColumns property takes precedences over values of IncludedColumns property
    */
    get dataToolTipIncludedColumns() {
        return this.i.l;
    }
    set dataToolTipIncludedColumns(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.l = v;
    }
    /**
     * Gets or sets names of data columns or their labels to exclude from displaying in the data legend, e.g. "High, Low" or "H, L"
     * The ExcludedColumns property takes precedences over values of IncludedColumns property
    */
    get dataToolTipExcludedColumns() {
        return this.i.i;
    }
    set dataToolTipExcludedColumns(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.i = v;
    }
    /**
     * Gets or sets mode for abbreviating large numbers displayed in the legend
     * This property is ignored when setting ValueFormatSpecifiers or ValueFormatString properties
    */
    get dataToolTipValueFormatAbbreviation() {
        return this.i.as;
    }
    set dataToolTipValueFormatAbbreviation(v) {
        this.i.as = ensureEnum(DataAbbreviationMode_$type, v);
    }
    /**
     * Gets or sets maximum digits for formating numbers displayed in the legend
     * This property is ignored when setting ValueFormatSpecifiers or ValueFormatString properties
    */
    get dataToolTipValueFormatMaxFractions() {
        return this.i.il;
    }
    set dataToolTipValueFormatMaxFractions(v) {
        this.i.il = +v;
    }
    /**
     * Gets or sets minimum digits for formating numbers displayed in the legend
     * This property is ignored when setting ValueFormatSpecifiers or ValueFormatString properties
    */
    get dataToolTipValueFormatMinFractions() {
        return this.i.im;
    }
    set dataToolTipValueFormatMinFractions(v) {
        this.i.im = +v;
    }
    /**
     * Gets or sets the mode for displaying values in the data legend, e.g. Currency ($500.25), Decimal (500.25), Integer (500)
    */
    get dataToolTipValueFormatMode() {
        return this.i.a6;
    }
    set dataToolTipValueFormatMode(v) {
        this.i.a6 = ensureEnum(DataLegendValueMode_$type, v);
    }
    /**
     * Gets or sets globalization culture when displaying values as currencies, e.g. use "en-GB" to display British pound symbol when the ValueFormatMode property is set to 'Currency' mode
     * This property is ignored when setting ValueFormatSpecifiers or ValueFormatString properties
    */
    get dataToolTipValueFormatCulture() {
        return this.i.l6;
    }
    set dataToolTipValueFormatCulture(v) {
        this.i.l6 = v;
    }
    /**
     * Gets or sets whether or not use groupping sperator, e.g, 15,000 for 15000
     * This property is ignored when setting ValueFormatSpecifiers or ValueFormatString properties
    */
    get dataToolTipValueFormatUseGrouping() {
        return this.i.ep;
    }
    set dataToolTipValueFormatUseGrouping(v) {
        this.i.ep = ensureBool(v);
    }
    /**
     * Gets or sets the format string for values displayed in the data legend.
    */
    get dataToolTipValueFormatString() {
        return this.i.mc;
    }
    set dataToolTipValueFormatString(v) {
        this.i.mc = v;
    }
    /**
     * Gets or sets the format specifiers to use with the ValueFormatString string.
    */
    get dataToolTipValueFormatSpecifiers() {
        return this.i.n;
    }
    set dataToolTipValueFormatSpecifiers(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.n = v;
    }
    get dataToolTipValueRowMarginBottom() {
        return this.i.tq ? this.i.tq.bottom : NaN;
    }
    set dataToolTipValueRowMarginBottom(v) {
        this.ensureDataToolTipValueRowMargin();
        this.i.tq.bottom = +v;
        this.i.tq = this.i.tq;
    }
    get dataToolTipValueRowMarginLeft() {
        return this.i.tq ? this.i.tq.left : NaN;
    }
    set dataToolTipValueRowMarginLeft(v) {
        this.ensureDataToolTipValueRowMargin();
        this.i.tq.left = +v;
        this.i.tq = this.i.tq;
    }
    get dataToolTipValueRowMarginRight() {
        return this.i.tq ? this.i.tq.right : NaN;
    }
    set dataToolTipValueRowMarginRight(v) {
        this.ensureDataToolTipValueRowMargin();
        this.i.tq.right = +v;
        this.i.tq = this.i.tq;
    }
    get dataToolTipValueRowMarginTop() {
        return this.i.tq ? this.i.tq.top : NaN;
    }
    set dataToolTipValueRowMarginTop(v) {
        this.ensureDataToolTipValueRowMargin();
        this.i.tq.top = +v;
        this.i.tq = this.i.tq;
    }
    ensureDataToolTipValueRowMargin() {
        if (this.i.tq) {
            return;
        }
        this.i.tq = new Thickness(2);
    }
    /**
     * Gets or sets whether to show series rows.
    */
    get dataToolTipValueRowVisible() {
        return this.i.eq;
    }
    set dataToolTipValueRowVisible(v) {
        this.i.eq = ensureBool(v);
    }
    /**
     * Gets or sets text displayed when data column is missing a value, e.g. "no data"
    */
    get dataToolTipValueTextWhenMissingData() {
        return this.i.ml;
    }
    set dataToolTipValueTextWhenMissingData(v) {
        this.i.ml = v;
    }
    /**
     * Gets or sets whether to use series colors when displaying values in the legend
    */
    get dataToolTipValueTextUseSeriesColors() {
        return this.i.er;
    }
    set dataToolTipValueTextUseSeriesColors(v) {
        this.i.er = ensureBool(v);
    }
    get dataToolTipValueTextMarginBottom() {
        return this.i.tr ? this.i.tr.bottom : NaN;
    }
    set dataToolTipValueTextMarginBottom(v) {
        this.ensureDataToolTipValueTextMargin();
        this.i.tr.bottom = +v;
        this.i.tr = this.i.tr;
    }
    get dataToolTipValueTextMarginLeft() {
        return this.i.tr ? this.i.tr.left : NaN;
    }
    set dataToolTipValueTextMarginLeft(v) {
        this.ensureDataToolTipValueTextMargin();
        this.i.tr.left = +v;
        this.i.tr = this.i.tr;
    }
    get dataToolTipValueTextMarginRight() {
        return this.i.tr ? this.i.tr.right : NaN;
    }
    set dataToolTipValueTextMarginRight(v) {
        this.ensureDataToolTipValueTextMargin();
        this.i.tr.right = +v;
        this.i.tr = this.i.tr;
    }
    get dataToolTipValueTextMarginTop() {
        return this.i.tr ? this.i.tr.top : NaN;
    }
    set dataToolTipValueTextMarginTop(v) {
        this.ensureDataToolTipValueTextMargin();
        this.i.tr.top = +v;
        this.i.tr = this.i.tr;
    }
    ensureDataToolTipValueTextMargin() {
        if (this.i.tr) {
            return;
        }
        this.i.tr = new Thickness(2);
    }
    /**
     * Gets or sets the units text color.
    */
    get dataToolTipValueTextColor() {
        return brushToString(this.i.sq);
    }
    set dataToolTipValueTextColor(v) {
        this.i.sq = stringToBrush(v);
    }
    /**
     * Gets or Sets the style to use for the units text.
    */
    get dataToolTipValueTextStyle() {
        if (this.i.dr == null) {
            return null;
        }
        return this.i.dr.fontString;
    }
    set dataToolTipValueTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.dr = fi;
    }
    /**
     * Gets or sets the format string for header text displayed in the data legend.
    */
    get dataToolTipHeaderFormatString() {
        return this.i.kw;
    }
    set dataToolTipHeaderFormatString(v) {
        this.i.kw = v;
    }
    /**
     * Gets or sets the format specifiers to use with the HeaderFormatString string.
    */
    get dataToolTipHeaderFormatSpecifiers() {
        return this.i.k;
    }
    set dataToolTipHeaderFormatSpecifiers(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.k = v;
    }
    /**
     * Gets or sets globalization culture when displaying header as date time
     * This property is ignored when setting HeaderFormatSpecifiers or HeaderFormatString properties
    */
    get dataToolTipHeaderFormatCulture() {
        return this.i.ks;
    }
    set dataToolTipHeaderFormatCulture(v) {
        this.i.ks = v;
    }
    /**
     * Gets or sets date format for the header
     * This property is ignored when setting HeaderFormatSpecifiers or HeaderFormatString properties
    */
    get dataToolTipHeaderFormatDate() {
        return this.i.aw;
    }
    set dataToolTipHeaderFormatDate(v) {
        this.i.aw = ensureEnum(DataLegendHeaderDateMode_$type, v);
    }
    /**
     * Gets or sets time format for the header
     * This property is ignored when setting HeaderFormatSpecifiers or HeaderFormatString properties
    */
    get dataToolTipHeaderFormatTime() {
        return this.i.ay;
    }
    set dataToolTipHeaderFormatTime(v) {
        this.i.ay = ensureEnum(DataLegendHeaderTimeMode_$type, v);
    }
    /**
     * Gets or sets the HeaderText for the data legend.
    */
    get dataToolTipHeaderText() {
        return this.i.k1;
    }
    set dataToolTipHeaderText(v) {
        this.i.k1 = v;
    }
    /**
     * Gets or sets the header text color.
    */
    get dataToolTipHeaderTextColor() {
        return brushToString(this.i.si);
    }
    set dataToolTipHeaderTextColor(v) {
        this.i.si = stringToBrush(v);
    }
    get dataToolTipHeaderTextMarginBottom() {
        return this.i.tk ? this.i.tk.bottom : NaN;
    }
    set dataToolTipHeaderTextMarginBottom(v) {
        this.ensureDataToolTipHeaderTextMargin();
        this.i.tk.bottom = +v;
        this.i.tk = this.i.tk;
    }
    get dataToolTipHeaderTextMarginLeft() {
        return this.i.tk ? this.i.tk.left : NaN;
    }
    set dataToolTipHeaderTextMarginLeft(v) {
        this.ensureDataToolTipHeaderTextMargin();
        this.i.tk.left = +v;
        this.i.tk = this.i.tk;
    }
    get dataToolTipHeaderTextMarginRight() {
        return this.i.tk ? this.i.tk.right : NaN;
    }
    set dataToolTipHeaderTextMarginRight(v) {
        this.ensureDataToolTipHeaderTextMargin();
        this.i.tk.right = +v;
        this.i.tk = this.i.tk;
    }
    get dataToolTipHeaderTextMarginTop() {
        return this.i.tk ? this.i.tk.top : NaN;
    }
    set dataToolTipHeaderTextMarginTop(v) {
        this.ensureDataToolTipHeaderTextMargin();
        this.i.tk.top = +v;
        this.i.tk = this.i.tk;
    }
    ensureDataToolTipHeaderTextMargin() {
        if (this.i.tk) {
            return;
        }
        this.i.tk = new Thickness(2);
    }
    get dataToolTipHeaderRowMarginBottom() {
        return this.i.tj ? this.i.tj.bottom : NaN;
    }
    set dataToolTipHeaderRowMarginBottom(v) {
        this.ensureDataToolTipHeaderRowMargin();
        this.i.tj.bottom = +v;
        this.i.tj = this.i.tj;
    }
    get dataToolTipHeaderRowMarginLeft() {
        return this.i.tj ? this.i.tj.left : NaN;
    }
    set dataToolTipHeaderRowMarginLeft(v) {
        this.ensureDataToolTipHeaderRowMargin();
        this.i.tj.left = +v;
        this.i.tj = this.i.tj;
    }
    get dataToolTipHeaderRowMarginRight() {
        return this.i.tj ? this.i.tj.right : NaN;
    }
    set dataToolTipHeaderRowMarginRight(v) {
        this.ensureDataToolTipHeaderRowMargin();
        this.i.tj.right = +v;
        this.i.tj = this.i.tj;
    }
    get dataToolTipHeaderRowMarginTop() {
        return this.i.tj ? this.i.tj.top : NaN;
    }
    set dataToolTipHeaderRowMarginTop(v) {
        this.ensureDataToolTipHeaderRowMargin();
        this.i.tj.top = +v;
        this.i.tj = this.i.tj;
    }
    ensureDataToolTipHeaderRowMargin() {
        if (this.i.tj) {
            return;
        }
        this.i.tj = new Thickness(2);
    }
    /**
     * Gets or sets whether to show Header row.
    */
    get dataToolTipHeaderRowVisible() {
        return this.i.en;
    }
    set dataToolTipHeaderRowVisible(v) {
        this.i.en = ensureBool(v);
    }
    /**
     * Gets or Sets the style to use for the header text.
    */
    get dataToolTipHeaderTextStyle() {
        if (this.i.di == null) {
            return null;
        }
        return this.i.di.fontString;
    }
    set dataToolTipHeaderTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.di = fi;
    }
    /**
     * Gets or sets the summary text color.
    */
    get dataToolTipSummaryTitleTextColor() {
        return brushToString(this.i.sl);
    }
    set dataToolTipSummaryTitleTextColor(v) {
        this.i.sl = stringToBrush(v);
    }
    /**
     * Gets or Sets the style to use for the summary text.
    */
    get dataToolTipSummaryTitleTextStyle() {
        if (this.i.dl == null) {
            return null;
        }
        return this.i.dl.fontString;
    }
    set dataToolTipSummaryTitleTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.dl = fi;
    }
    /**
     * Gets or sets the SummaryType for the data legend.
    */
    get dataToolTipSummaryType() {
        return this.i.a2;
    }
    set dataToolTipSummaryType(v) {
        this.i.a2 = ensureEnum(DataLegendSummaryType_$type, v);
    }
    /**
     * Gets or sets the SummaryTitleText for the data legend.
    */
    get dataToolTipSummaryTitleText() {
        return this.i.lk;
    }
    set dataToolTipSummaryTitleText(v) {
        this.i.lk = v;
    }
    get dataToolTipSummaryTitleTextMarginBottom() {
        return this.i.tn ? this.i.tn.bottom : NaN;
    }
    set dataToolTipSummaryTitleTextMarginBottom(v) {
        this.ensureDataToolTipSummaryTitleTextMargin();
        this.i.tn.bottom = +v;
        this.i.tn = this.i.tn;
    }
    get dataToolTipSummaryTitleTextMarginLeft() {
        return this.i.tn ? this.i.tn.left : NaN;
    }
    set dataToolTipSummaryTitleTextMarginLeft(v) {
        this.ensureDataToolTipSummaryTitleTextMargin();
        this.i.tn.left = +v;
        this.i.tn = this.i.tn;
    }
    get dataToolTipSummaryTitleTextMarginRight() {
        return this.i.tn ? this.i.tn.right : NaN;
    }
    set dataToolTipSummaryTitleTextMarginRight(v) {
        this.ensureDataToolTipSummaryTitleTextMargin();
        this.i.tn.right = +v;
        this.i.tn = this.i.tn;
    }
    get dataToolTipSummaryTitleTextMarginTop() {
        return this.i.tn ? this.i.tn.top : NaN;
    }
    set dataToolTipSummaryTitleTextMarginTop(v) {
        this.ensureDataToolTipSummaryTitleTextMargin();
        this.i.tn.top = +v;
        this.i.tn = this.i.tn;
    }
    ensureDataToolTipSummaryTitleTextMargin() {
        if (this.i.tn) {
            return;
        }
        this.i.tn = new Thickness(2);
    }
    get dataToolTipSummaryRowMarginBottom() {
        return this.i.tm ? this.i.tm.bottom : NaN;
    }
    set dataToolTipSummaryRowMarginBottom(v) {
        this.ensureDataToolTipSummaryRowMargin();
        this.i.tm.bottom = +v;
        this.i.tm = this.i.tm;
    }
    get dataToolTipSummaryRowMarginLeft() {
        return this.i.tm ? this.i.tm.left : NaN;
    }
    set dataToolTipSummaryRowMarginLeft(v) {
        this.ensureDataToolTipSummaryRowMargin();
        this.i.tm.left = +v;
        this.i.tm = this.i.tm;
    }
    get dataToolTipSummaryRowMarginRight() {
        return this.i.tm ? this.i.tm.right : NaN;
    }
    set dataToolTipSummaryRowMarginRight(v) {
        this.ensureDataToolTipSummaryRowMargin();
        this.i.tm.right = +v;
        this.i.tm = this.i.tm;
    }
    get dataToolTipSummaryRowMarginTop() {
        return this.i.tm ? this.i.tm.top : NaN;
    }
    set dataToolTipSummaryRowMarginTop(v) {
        this.ensureDataToolTipSummaryRowMargin();
        this.i.tm.top = +v;
        this.i.tm = this.i.tm;
    }
    ensureDataToolTipSummaryRowMargin() {
        if (this.i.tm) {
            return;
        }
        this.i.tm = new Thickness(2);
    }
    /**
     * Gets or sets the units text color.
    */
    get dataToolTipSummaryValueTextColor() {
        return brushToString(this.i.sn);
    }
    set dataToolTipSummaryValueTextColor(v) {
        this.i.sn = stringToBrush(v);
    }
    /**
     * Gets or Sets the style to use for the units text.
    */
    get dataToolTipSummaryValueTextStyle() {
        if (this.i.dn == null) {
            return null;
        }
        return this.i.dn.fontString;
    }
    set dataToolTipSummaryValueTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.dn = fi;
    }
    /**
     * Gets or sets the units text for the data legend.
    */
    get dataToolTipSummaryLabelText() {
        return this.i.lf;
    }
    set dataToolTipSummaryLabelText(v) {
        this.i.lf = v;
    }
    /**
     * Gets or sets the units text color.
    */
    get dataToolTipSummaryLabelTextColor() {
        return brushToString(this.i.sk);
    }
    set dataToolTipSummaryLabelTextColor(v) {
        this.i.sk = stringToBrush(v);
    }
    /**
     * Gets or Sets the style to use for the units text.
    */
    get dataToolTipSummaryLabelTextStyle() {
        if (this.i.dk == null) {
            return null;
        }
        return this.i.dk.fontString;
    }
    set dataToolTipSummaryLabelTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.dk = fi;
    }
    /**
     * Gets or sets the units text for the data legend.
    */
    get dataToolTipSummaryUnitsText() {
        return this.i.lq;
    }
    set dataToolTipSummaryUnitsText(v) {
        this.i.lq = v;
    }
    /**
     * Gets or sets the units text color.
    */
    get dataToolTipSummaryUnitsTextColor() {
        return brushToString(this.i.sm);
    }
    set dataToolTipSummaryUnitsTextColor(v) {
        this.i.sm = stringToBrush(v);
    }
    /**
     * Gets or Sets the style to use for the units text.
    */
    get dataToolTipSummaryUnitsTextStyle() {
        if (this.i.dm == null) {
            return null;
        }
        return this.i.dm.fontString;
    }
    set dataToolTipSummaryUnitsTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.dm = fi;
    }
    get dataToolTipBadgeMarginBottom() {
        return this.i.ti ? this.i.ti.bottom : NaN;
    }
    set dataToolTipBadgeMarginBottom(v) {
        this.ensureDataToolTipBadgeMargin();
        this.i.ti.bottom = +v;
        this.i.ti = this.i.ti;
    }
    get dataToolTipBadgeMarginLeft() {
        return this.i.ti ? this.i.ti.left : NaN;
    }
    set dataToolTipBadgeMarginLeft(v) {
        this.ensureDataToolTipBadgeMargin();
        this.i.ti.left = +v;
        this.i.ti = this.i.ti;
    }
    get dataToolTipBadgeMarginRight() {
        return this.i.ti ? this.i.ti.right : NaN;
    }
    set dataToolTipBadgeMarginRight(v) {
        this.ensureDataToolTipBadgeMargin();
        this.i.ti.right = +v;
        this.i.ti = this.i.ti;
    }
    get dataToolTipBadgeMarginTop() {
        return this.i.ti ? this.i.ti.top : NaN;
    }
    set dataToolTipBadgeMarginTop(v) {
        this.ensureDataToolTipBadgeMargin();
        this.i.ti.top = +v;
        this.i.ti = this.i.ti;
    }
    ensureDataToolTipBadgeMargin() {
        if (this.i.ti) {
            return;
        }
        this.i.ti = new Thickness(2);
    }
    /**
     * Gets or sets the BadgeShape for the data legend.
    */
    get dataToolTipBadgeShape() {
        return this.i.bw;
    }
    set dataToolTipBadgeShape(v) {
        this.i.bw = ensureEnum(LegendItemBadgeShape_$type, v);
    }
    /**
     * Gets or sets the UnitsMode for the data legend.
    */
    get dataToolTipUnitsDisplayMode() {
        return this.i.a4;
    }
    set dataToolTipUnitsDisplayMode(v) {
        this.i.a4 = ensureEnum(DataLegendUnitsMode_$type, v);
    }
    /**
     * Gets or sets the units text for the data legend.
    */
    get dataToolTipUnitsText() {
        return this.i.l0;
    }
    set dataToolTipUnitsText(v) {
        this.i.l0 = v;
    }
    /**
     * Gets or sets the units text color.
    */
    get dataToolTipUnitsTextColor() {
        return brushToString(this.i.sp);
    }
    set dataToolTipUnitsTextColor(v) {
        this.i.sp = stringToBrush(v);
    }
    get dataToolTipUnitsTextMarginBottom() {
        return this.i.tp ? this.i.tp.bottom : NaN;
    }
    set dataToolTipUnitsTextMarginBottom(v) {
        this.ensureDataToolTipUnitsTextMargin();
        this.i.tp.bottom = +v;
        this.i.tp = this.i.tp;
    }
    get dataToolTipUnitsTextMarginLeft() {
        return this.i.tp ? this.i.tp.left : NaN;
    }
    set dataToolTipUnitsTextMarginLeft(v) {
        this.ensureDataToolTipUnitsTextMargin();
        this.i.tp.left = +v;
        this.i.tp = this.i.tp;
    }
    get dataToolTipUnitsTextMarginRight() {
        return this.i.tp ? this.i.tp.right : NaN;
    }
    set dataToolTipUnitsTextMarginRight(v) {
        this.ensureDataToolTipUnitsTextMargin();
        this.i.tp.right = +v;
        this.i.tp = this.i.tp;
    }
    get dataToolTipUnitsTextMarginTop() {
        return this.i.tp ? this.i.tp.top : NaN;
    }
    set dataToolTipUnitsTextMarginTop(v) {
        this.ensureDataToolTipUnitsTextMargin();
        this.i.tp.top = +v;
        this.i.tp = this.i.tp;
    }
    ensureDataToolTipUnitsTextMargin() {
        if (this.i.tp) {
            return;
        }
        this.i.tp = new Thickness(2);
    }
    /**
     * Gets or Sets the style to use for the units text.
    */
    get dataToolTipUnitsTextStyle() {
        if (this.i.dq == null) {
            return null;
        }
        return this.i.dq.fontString;
    }
    set dataToolTipUnitsTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.dq = fi;
    }
    get dataToolTipTitleTextMarginBottom() {
        return this.i.to ? this.i.to.bottom : NaN;
    }
    set dataToolTipTitleTextMarginBottom(v) {
        this.ensureDataToolTipTitleTextMargin();
        this.i.to.bottom = +v;
        this.i.to = this.i.to;
    }
    get dataToolTipTitleTextMarginLeft() {
        return this.i.to ? this.i.to.left : NaN;
    }
    set dataToolTipTitleTextMarginLeft(v) {
        this.ensureDataToolTipTitleTextMargin();
        this.i.to.left = +v;
        this.i.to = this.i.to;
    }
    get dataToolTipTitleTextMarginRight() {
        return this.i.to ? this.i.to.right : NaN;
    }
    set dataToolTipTitleTextMarginRight(v) {
        this.ensureDataToolTipTitleTextMargin();
        this.i.to.right = +v;
        this.i.to = this.i.to;
    }
    get dataToolTipTitleTextMarginTop() {
        return this.i.to ? this.i.to.top : NaN;
    }
    set dataToolTipTitleTextMarginTop(v) {
        this.ensureDataToolTipTitleTextMargin();
        this.i.to.top = +v;
        this.i.to = this.i.to;
    }
    ensureDataToolTipTitleTextMargin() {
        if (this.i.to) {
            return;
        }
        this.i.to = new Thickness(2);
    }
    /**
     * Gets or sets the display text color.
    */
    get dataToolTipTitleTextColor() {
        return brushToString(this.i.so);
    }
    set dataToolTipTitleTextColor(v) {
        this.i.so = stringToBrush(v);
    }
    /**
     * Gets or Sets the style to use for the display text.
    */
    get dataToolTipTitleTextStyle() {
        if (this.i.dp == null) {
            return null;
        }
        return this.i.dp.fontString;
    }
    set dataToolTipTitleTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.dp = fi;
    }
    /**
     * Gets or sets the mode for displaying labels before series values in the data legend, e.g. O: H: L: C: for financial series
    */
    get dataToolTipLabelDisplayMode() {
        return this.i.a0;
    }
    set dataToolTipLabelDisplayMode(v) {
        this.i.a0 = ensureEnum(DataLegendLabelMode_$type, v);
    }
    /**
     * Gets or sets the units text color.
    */
    get dataToolTipLabelTextColor() {
        return brushToString(this.i.sj);
    }
    set dataToolTipLabelTextColor(v) {
        this.i.sj = stringToBrush(v);
    }
    get dataToolTipLabelTextMarginBottom() {
        return this.i.tl ? this.i.tl.bottom : NaN;
    }
    set dataToolTipLabelTextMarginBottom(v) {
        this.ensureDataToolTipLabelTextMargin();
        this.i.tl.bottom = +v;
        this.i.tl = this.i.tl;
    }
    get dataToolTipLabelTextMarginLeft() {
        return this.i.tl ? this.i.tl.left : NaN;
    }
    set dataToolTipLabelTextMarginLeft(v) {
        this.ensureDataToolTipLabelTextMargin();
        this.i.tl.left = +v;
        this.i.tl = this.i.tl;
    }
    get dataToolTipLabelTextMarginRight() {
        return this.i.tl ? this.i.tl.right : NaN;
    }
    set dataToolTipLabelTextMarginRight(v) {
        this.ensureDataToolTipLabelTextMargin();
        this.i.tl.right = +v;
        this.i.tl = this.i.tl;
    }
    get dataToolTipLabelTextMarginTop() {
        return this.i.tl ? this.i.tl.top : NaN;
    }
    set dataToolTipLabelTextMarginTop(v) {
        this.ensureDataToolTipLabelTextMargin();
        this.i.tl.top = +v;
        this.i.tl = this.i.tl;
    }
    ensureDataToolTipLabelTextMargin() {
        if (this.i.tl) {
            return;
        }
        this.i.tl = new Thickness(2);
    }
    /**
     * Gets or Sets the style to use for the units text.
    */
    get dataToolTipLabelTextStyle() {
        if (this.i.dj == null) {
            return null;
        }
        return this.i.dj.fontString;
    }
    set dataToolTipLabelTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.dj = fi;
    }
    /**
     * Gets the domain type of this chart
    */
    get domainType() {
        return this.i.bi;
    }
    /**
     * Gets or sets a set of property paths that should be included for consideration by the category chart, leaving the remainder excluded. If null, all properties will be considered.
    *
    * The `includedProperties` property used to include the properties for the consideration of the category chart.
    *
    * ```ts
    * this.chart.includedProperties = ["ProductName", "Cost"];
    * ```
    *
    * ```ts
    * 	<IgrCategoryChart
    * 		chartType="Line"
    * 		markerTypes={this.state.markersTypes}
    * 		dataSource={this.categoryData}
    * 		excludedProperties="value" />
    * ```
    */
    get includedProperties() {
        return this.i.q;
    }
    set includedProperties(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.q = v;
    }
    /**
     * Gets or sets a set of property paths that should be excluded from consideration by the category chart.
    *
    * The `excludedProperties` property used for the property paths that should be excluded from consideration by the category chart.
    *
    * ```ts
    * this.chart.excludedProperties = ["ID", "Discount"];
    * ```
    *
    * ```ts
    * 	<IgrCategoryChart
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	excludedProperties="value" />
    * ```
    */
    get excludedProperties() {
        return this.i.o;
    }
    set excludedProperties(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.o = v;
    }
    /**
     * Gets or sets the palette of brushes to use for coloring the chart series.
     * The value provided should be an array of CSS color strings or JavaScript objects defining gradients. Optionally the first element can be a string reading "RGB" or "HSV" to specify the interpolation mode of the collection
    *
    * Use the `brushes` property to  set the brushes.
    *
    * ```ts
    * this.chart.brushes = ["#ff0000","#00ff00"];
    * ```
    */
    get brushes() {
        return fromBrushCollection(this.i.aa);
    }
    set brushes(v) {
        this.i.aa = toBrushCollection(v);
    }
    /**
     * Gets or sets the palette of brushes to use for outlines on the chart series.
     * The value provided should be an array of CSS color strings or JavaScript objects defining gradients. Optionally the first element can be a string reading "RGB" or "HSV" to specify the interpolation mode of the collection
    *
    *  Use the `outlines` property to sets the palette of brushes to use for outlines on the chart series
    *
    * ```ts
    * <IgrCategoryChart
    * 	chartType="Line"
    * 	outlines= "#ff0000"
    * 	dataSource={this.categoryData}/>
    * ```
    */
    get outlines() {
        return fromBrushCollection(this.i.ae);
    }
    set outlines(v) {
        this.i.ae = toBrushCollection(v);
    }
    /**
     * Gets the actual palette of brushes to use for coloring the chart series.
    */
    get actualBrushes() {
        return fromBrushCollection(this.i.y);
    }
    set actualBrushes(v) {
        this.i.y = toBrushCollection(v);
    }
    /**
     * Gets the actual palette of brushes to use for outlines on the chart series.
    */
    get actualOutlines() {
        return fromBrushCollection(this.i.z);
    }
    set actualOutlines(v) {
        this.i.z = toBrushCollection(v);
    }
    /**
     * Gets or sets whether the chart can be horizontally zoomed through user interactions.
    *
    * Use the `isHorizontalZoomEnabled` property to allow chart horizontally zoomed .
    *
    * ```ts
    *  <IgrCategoryChart dataSource={this.state.data}
    *                    width="700px"
    *                    height="500px"
    *                    xAxisLabelTextStyle="10pt Verdana"
    *                    xAxisLabelTopMargin={5}
    *                    xAxisLabelTextColor="gray"
    *                    yAxisLabelTextStyle="10pt Verdana"
    *                    yAxisLabelRightMargin={5}
    *                    yAxisLabelTextColor="gray"
    * 				   isHorizontalZoomEnabled= true/>
    * ```
    *
    * ```ts
    *  <IgrCategoryChart dataSource={this.state.data}
    *                    IsHorizontalZoomEnabled= true />
    * ```
    *
    * ```ts
    * this.chart.isHorizontalZoomEnabled = true;
    * ```
    */
    get isHorizontalZoomEnabled() {
        return this.i.e0;
    }
    set isHorizontalZoomEnabled(v) {
        this.i.e0 = ensureBool(v);
    }
    /**
     * Gets or sets whether the chart can be vertically zoomed through user interactions.
    *
    * Use the `isVerticalZoomEnabled` property to allow chart zoom vertically.
    *
    * ```ts
    *  this.chart.isVerticalZoomEnabled = true;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart dataSource={this.state.data}
    *                   isVerticalZoomEnabled= "true"/>
    * ```
    */
    get isVerticalZoomEnabled() {
        return this.i.e6;
    }
    set isVerticalZoomEnabled(v) {
        this.i.e6 = ensureBool(v);
    }
    /**
     * Gets or sets whether the chart should display mock data when the data source has not been provided, if supported for this type of chart.
    */
    get shouldDisplayMockData() {
        return this.i.e9;
    }
    set shouldDisplayMockData(v) {
        this.i.e9 = ensureBool(v);
    }
    /**
     * Gets or sets whether the chart should use a faded skeleton style for mock data.
    */
    get shouldUseSkeletonStyleForMockData() {
        return this.i.fa;
    }
    set shouldUseSkeletonStyleForMockData(v) {
        this.i.fa = ensureBool(v);
    }
    /**
     * Gets or sets whether the chart can highlight series through user interactions.
     * This property applies to Category Chart and Financial Chart controls.
    */
    get isSeriesHighlightingEnabled() {
        return this.i.e2;
    }
    set isSeriesHighlightingEnabled(v) {
        this.i.e2 = ensureBool(v);
    }
    /**
     * Gets or sets the rectangle representing the current scroll and zoom state of the chart.
     * WindowRect is expressed as a Rectangle with coordinates and sizes between 0 and 1.
    *
    * Use `windowRect` property representing the current scroll and zoom state of the chart.
    *
    * ```ts
    * this.chart.windowRect =[0,0,1,1];
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                WindowRect={1,0,1,1} />
    * ```
    */
    get windowRect() {
        return fromRect(this.i.s7);
    }
    set windowRect(v) {
        this.i.s7 = toRect(v);
    }
    /**
     * Gets a rectangle representing the bounds of the plot area.
    *
    * `viewport` property representing the bounds of the plot area.
    *
    * ```ts
    * let viewport:Rect =  this.chart.viewport;
    * ```
    */
    get viewport() {
        return fromRect(this.i.s6);
    }
    /**
     * Gets or sets text to display above the plot area.
    *
    * Use the `chartTitle` property to display the text above the plot area.
    *
    * ```ts
    *  this.chart.title= "This is a Title";
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	title= "CategoryChart Subtitle"	/>
    * ```
    */
    get chartTitle() {
        return this.i.oh;
    }
    set chartTitle(v) {
        this.i.oh = v;
    }
    /**
     * Gets or sets text to display below the Title, above the plot area.
    *
    * Use the `subtitle` property to display the text below  and above the plot area.
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitle= "CategoryChart Subtitle"/>
    * ```
    *
    * ```ts
    *  this.chart.subtitle ="CategoryChart Subtitle" ;
    * ```
    */
    get subtitle() {
        return this.i.n6;
    }
    set subtitle(v) {
        this.i.n6 = v;
    }
    /**
     * Gets or sets horizontal alignment which determines the title position, relative to the left and right edges of the control.
    *
    * Use the `titleAlignment` property for the horizontal alignment of the title.
    *
    * ```ts
    * this.chart.titleAlignment = HorizontalAlignment.Center;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	titleAlignment= "Center"/>
    * ```
    */
    get titleAlignment() {
        return this.i.ro;
    }
    set titleAlignment(v) {
        this.i.ro = ensureEnum(HorizontalAlignment_$type, v);
    }
    /**
     * Gets or sets horizontal alignment which determines the subtitle position, relative to the left and right edges of the control.
    *
    * Use the `subtitleAlignment` property to Gets or sets horizontal alignment.
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitle= "CategoryChart Subtitle"
    * 	subtitleAlignment="Right"/>
    * ```
    *
    * ```ts
    * this.chart.subtitleAlignment = HorizontalAlignment.Right;
    * ```
    */
    get subtitleAlignment() {
        return this.i.rn;
    }
    set subtitleAlignment(v) {
        this.i.rn = ensureEnum(HorizontalAlignment_$type, v);
    }
    /**
     * Gets or sets the behavior that determines how unknown values will be plotted on the chart.
     * Null and Double.NaN are two examples of unknown values.
    *
    * Use the `unknownValuePlotting` property to determines the behavior that how unknown values will be plotted on the chart.
    *
    * ```ts
    * this.chart.unknownValuePlotting =UnknownValuePlotting.DontPlot;
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                unknownValuePlotting= "dontPlot" />
    * ```
    */
    get unknownValuePlotting() {
        return this.i.c4;
    }
    set unknownValuePlotting(v) {
        this.i.c4 = ensureEnum(UnknownValuePlotting_$type, v);
    }
    /**
     * Gets or sets the rendering resolution for all series in this chart.
     * Where n = Resolution, for every n horizontal pixels, combine all items into a single data point.  When Resolution = 0, all data points will be rendered as graphical objects.  Charts with a higher resolution will have faster performance.
    *
    * Use the `resolution` property if the callouts should be display.
    *
    * ```ts
    *   this.chart.resolution = 2 ;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	calloutsVisible="true"
    * 	resolution= {2}/>
    * ```
    */
    get resolution() {
        return this.i.hn;
    }
    set resolution(v) {
        this.i.hn = +v;
    }
    /**
     * Gets or sets the thickness for all series in this chart. Depending on the ChartType, this can be the main brush used, or just the outline.
    *
    * Use the `thickness` property for the thickness of all the series in this chart.
    */
    get thickness() {
        return this.i.ht;
    }
    set thickness(v) {
        this.i.ht = +v;
    }
    /**
     * Gets or sets the OutlineMode for all series in this chart.
    */
    get outlineMode() {
        return this.i.cm;
    }
    set outlineMode(v) {
        this.i.cm = ensureEnum(SeriesOutlineMode_$type, v);
    }
    /**
     * Gets or sets the MarkerOutlineMode for all series that support markers in this chart.
    */
    get markerOutlineMode() {
        return this.i.b3;
    }
    set markerOutlineMode(v) {
        this.i.b3 = ensureEnum(MarkerOutlineMode_$type, v);
    }
    /**
     * Gets or sets the MarkerFillMode for all series that support markers in this chart.
    */
    get markerFillMode() {
        return this.i.b1;
    }
    set markerFillMode(v) {
        this.i.b1 = ensureEnum(MarkerFillMode_$type, v);
    }
    /**
     * Gets or sets the Marker Fill Opacity for all series that support markers in this chart.
    */
    get markerFillOpacity() {
        return this.i.hg;
    }
    set markerFillOpacity(v) {
        this.i.hg = +v;
    }
    /**
     * Gets or sets the Marker Thickness for all series that support markers in this chart.
    */
    get markerThickness() {
        return this.i.hh;
    }
    set markerThickness(v) {
        this.i.hh = +v;
    }
    /**
     * Gets or sets the marker shapes used for indicating location of data points in this chart.
     * This property applies only to these chart types: point, line, spline, bubble, and polygon
    */
    get markerTypes() {
        if (this._markerTypes === null) {
            let coll = new IgrMarkerTypeCollection();
            let innerColl = this.i.b8;
            if (!innerColl) {
                innerColl = new MarkerTypeCollection_internal();
            }
            this._markerTypes = coll._fromInner(innerColl);
            this.i.b8 = innerColl;
        }
        return this._markerTypes;
    }
    set markerTypes(v) {
        if (this._markerTypes !== null) {
            this._markerTypes._setSyncTarget(null);
            this._markerTypes = null;
        }
        let coll = new IgrMarkerTypeCollection();
        this._markerTypes = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(MarkerType_$type);
        let innerColl = this.i.b8;
        if (!innerColl) {
            innerColl = new MarkerTypeCollection_internal();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._markerTypes._setSyncTarget(syncColl);
        this.i.b8 = innerColl;
    }
    /**
     * Gets or sets the default marker type for all series plotted in this chart.
     * This property is ignored when the MarkerTypes property is set
    */
    get markerAutomaticBehavior() {
        return this.i.bz;
    }
    set markerAutomaticBehavior(v) {
        this.i.bz = ensureEnum(MarkerAutomaticBehavior_$type, v);
    }
    /**
     * Gets or sets the palette of brushes used for rendering fill area of data point markers.
     * This property applies only to these chart types: point, line, spline, bubble, and polygon
    *
    * `markerBrushes` property used for rendering fill area of data point markers.
    *
    * ```ts
    *  this.chart.markerBrushes=[ "#ff0000", "#ffff00", "#00ffff" ];
    * ```
    *
    * ```ts
    * <IgrCategoryChart
    *     chartType="Line"
    *     markerBrushes ="#ffff00"
    *     dataSource={this.categoryData}/>
    * ```
    */
    get markerBrushes() {
        return fromBrushCollection(this.i.ac);
    }
    set markerBrushes(v) {
        this.i.ac = toBrushCollection(v);
    }
    /**
     * Gets or sets the palette of brushes used for rendering outlines of data point markers.
     * This property applies only to these chart types: point, line, spline, bubble, and polygon
    *
    * `markerOutlines` property used for rendering outlines of data point markers.
    *
    * ```ts
    * this.chart.markerOutlines= ["#ff0000", "#ffff00", "#00ffff"] ;
    * ```
    *
    * ```ts
    * <IgrCategoryChart
    * 	chartType="Line"
    * 	markerOutlines= "#ff0000"
    * 	dataSource={this.categoryData}/>
    * ```
    */
    get markerOutlines() {
        return fromBrushCollection(this.i.ad);
    }
    set markerOutlines(v) {
        this.i.ad = toBrushCollection(v);
    }
    /**
     * Gets or sets the maximum number of markers displayed in the plot area of the chart.
    *
    * `markerMaxCount` property used to display maximum number of markers in the plot area of the chart.
    *
    * ```ts
    *  this.chart.markerMaxCount = 100 ;
    * ```
    *
    * ```ts
    * <IgrCategoryChart
    * 	chartType="Line"
    * 	markerMaxCount= {2}
    * 	dataSource={this.categoryData}/>
    * ```
    */
    get markerMaxCount() {
        return this.i.ip;
    }
    set markerMaxCount(v) {
        this.i.ip = +v;
    }
    /**
     * Gets or sets the fill opacity for all series that have area visuals in this chart.
     * For example, Area, SplineArea, Column chart types
    */
    get areaFillOpacity() {
        return this.i.g1;
    }
    set areaFillOpacity(v) {
        this.i.g1 = +v;
    }
    /**
     * Gets or sets whether the series animations should be allowed when a range change has been detected on an axis.
    */
    get animateSeriesWhenAxisRangeChanges() {
        return this.i.eh;
    }
    set animateSeriesWhenAxisRangeChanges(v) {
        this.i.eh = ensureBool(v);
    }
    /**
     * Gets or sets the palette of brushes to used for coloring trend lines in this chart.
     * The value provided should be an array of CSS color strings or JavaScript objects defining gradients. Optionally the first element can be a string reading "RGB" or "HSV" to specify the interpolation mode of the collection
    *
    * Use the `trendLineBrushes` property for coloring trend lines in the chart.
    *
    * ```ts
    * this.chart.trendLineBrushes=["#ff0000", "#ffff00", "#00ffff"]	;
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                trendLineBrushes="#ffff00" />
    * ```
    */
    get trendLineBrushes() {
        return fromBrushCollection(this.i.ag);
    }
    set trendLineBrushes(v) {
        this.i.ag = toBrushCollection(v);
    }
    /**
     * Gets or sets the formula used for calculating trend lines in this chart.
     * This property applies only to these chart types: point, line, spline, and bubble
    *
    * Use the `trendLineType` property for calculating trend lines.
    *
    * ```ts
    * this.chart.trendLineType = TrendLineType.CubicFit;
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                trendLineType="CubicFit" />
    * ```
    */
    get trendLineType() {
        return this.i.c2;
    }
    set trendLineType(v) {
        this.i.c2 = ensureEnum(TrendLineType_$type, v);
    }
    /**
     * Gets or sets the thickness of the trend lines in this chart.
     * This property applies only to these chart types: point, line, spline, and bubble
    *
    * Use the `trendLineThickness` property for the thickness of the trend lines in the chart.
    *
    * ```ts
    * this.chart.trendLineThickness=2;
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                trendLineThickness={2} />
    * ```
    */
    get trendLineThickness() {
        return this.i.hz;
    }
    set trendLineThickness(v) {
        this.i.hz = +v;
    }
    /**
     * Gets or sets a value indicating whether grid and tick lines are aligned to device pixels.
    *
    * Use `alignsGridLinesToPixels` propert to indicat whether grid and tick lines are aligned to device pixels.
    *
    * ```ts
    *  this.chart.alignsGridLinesToPixels= true;
    * ```
    */
    get alignsGridLinesToPixels() {
        return this.i.eg;
    }
    set alignsGridLinesToPixels(v) {
        this.i.eg = ensureBool(v);
    }
    /**
     * Margin applied to the Left of the plot area.
    */
    get plotAreaMarginLeft() {
        return this.i.hk;
    }
    set plotAreaMarginLeft(v) {
        this.i.hk = +v;
    }
    /**
     * Margin applied to the Top of the plot area.
    */
    get plotAreaMarginTop() {
        return this.i.hm;
    }
    set plotAreaMarginTop(v) {
        this.i.hm = +v;
    }
    /**
     * Margin applied to the right of the plot area.
    */
    get plotAreaMarginRight() {
        return this.i.hl;
    }
    set plotAreaMarginRight(v) {
        this.i.hl = +v;
    }
    /**
     * Margin applied below the plot area.
    */
    get plotAreaMarginBottom() {
        return this.i.hj;
    }
    set plotAreaMarginBottom(v) {
        this.i.hj = +v;
    }
    /**
     * Gets or sets mode to use for automatically calculating the plot area margin.
    */
    get computedPlotAreaMarginMode() {
        return this.i.ao;
    }
    set computedPlotAreaMarginMode(v) {
        this.i.ao = ensureEnum(ComputedPlotAreaMarginMode_$type, v);
    }
    /**
     * Gets or sets horizontal mode to use for automatically calculating the plot area margin based ont the series.
    */
    get seriesPlotAreaMarginHorizontalMode() {
        return this.i.co;
    }
    set seriesPlotAreaMarginHorizontalMode(v) {
        this.i.co = ensureEnum(SeriesPlotAreaMarginHorizontalMode_$type, v);
    }
    /**
     * Gets or sets vertical mode to use for automatically calculating the plot area margin based ont the series.
    */
    get seriesPlotAreaMarginVerticalMode() {
        return this.i.cq;
    }
    set seriesPlotAreaMarginVerticalMode(v) {
        this.i.cq = ensureEnum(SeriesPlotAreaMarginVerticalMode_$type, v);
    }
    /**
     * Gets or sets the highlighting mode to use for the series in the component, when supported. This takes precedence over the series level IsHightlightingEnabled.
    */
    get highlightingMode() {
        return this.i.ck;
    }
    set highlightingMode(v) {
        this.i.ck = ensureEnum(SeriesHighlightingMode_$type, v);
    }
    /**
     * Gets or sets the highlighting Behavior to use for the series in the component, when supported. This takes precedence over the series level IsHightlightingEnabled.
    */
    get highlightingBehavior() {
        return this.i.ci;
    }
    set highlightingBehavior(v) {
        this.i.ci = ensureEnum(SeriesHighlightingBehavior_$type, v);
    }
    /**
     * Gets or sets the highlighting mode to use for the legend linked to the component, when supported.
    */
    get legendHighlightingMode() {
        return this.i.br;
    }
    set legendHighlightingMode(v) {
        this.i.br = ensureEnum(LegendHighlightingMode_$type, v);
    }
    /**
     * Gets or sets the type of legend badges representing all series displayed in a legend linked to this component
     * This property will be ignored when the LegendItemTemplate or LegendItemBadgeTemplate property is set on a series
    */
    get legendItemBadgeShape() {
        return this.i.bx;
    }
    set legendItemBadgeShape(v) {
        this.i.bx = ensureEnum(LegendItemBadgeShape_$type, v);
    }
    /**
     * Gets or sets the mode of legend badges representing all series displayed in a legend linked to this component.
     * This property will be ignored when the LegendItemTemplate or LegendItemBadgeTemplate property is set on a series
    */
    get legendItemBadgeMode() {
        return this.i.bt;
    }
    set legendItemBadgeMode(v) {
        this.i.bt = ensureEnum(LegendItemBadgeMode_$type, v);
    }
    get trendLinePeriod() {
        return this.i.ir;
    }
    set trendLinePeriod(v) {
        this.i.ir = +v;
    }
    /**
     * Gets or sets the style of tooltip to be displayed.
    */
    get toolTipType() {
        return this.i.c0;
    }
    set toolTipType(v) {
        this.i.c0 = ensureEnum(ToolTipType_$type, v);
    }
    /**
     * Gets or sets the crosshairs to be displayed.
    */
    get crosshairsDisplayMode() {
        return this.i.aq;
    }
    set crosshairsDisplayMode(v) {
        this.i.aq = ensureEnum(CrosshairsDisplayMode_$type, v);
    }
    /**
     * Gets or sets whether crosshairs will snap to the nearest data point.
    */
    get crosshairsSnapToData() {
        return this.i.em;
    }
    set crosshairsSnapToData(v) {
        this.i.em = ensureBool(v);
    }
    /**
     * Gets or sets the color to apply to vertical crosshairs line.
    */
    get crosshairsLineVerticalStroke() {
        return brushToString(this.i.sh);
    }
    set crosshairsLineVerticalStroke(v) {
        this.i.sh = stringToBrush(v);
    }
    /**
     * Gets or sets thickness of crosshairs lines.
    */
    get crosshairsLineThickness() {
        return this.i.g3;
    }
    set crosshairsLineThickness(v) {
        this.i.g3 = +v;
    }
    /**
     * Gets or sets the color to apply to horizontal crosshairs line.
    */
    get crosshairsLineHorizontalStroke() {
        return brushToString(this.i.sg);
    }
    set crosshairsLineHorizontalStroke(v) {
        this.i.sg = stringToBrush(v);
    }
    /**
     * Gets or sets whether annotations are shown along the axis for crosshair values
    */
    get crosshairsAnnotationEnabled() {
        return this.i.el;
    }
    set crosshairsAnnotationEnabled(v) {
        this.i.el = ensureBool(v);
    }
    /**
     * Gets or sets the background of crosshair annotation on x-axis.
    */
    get crosshairsAnnotationXAxisBackground() {
        return brushToString(this.i.sc);
    }
    set crosshairsAnnotationXAxisBackground(v) {
        this.i.sc = stringToBrush(v);
    }
    /**
     * Gets or sets the background of crosshair annotation on y-axis.
    */
    get crosshairsAnnotationYAxisBackground() {
        return brushToString(this.i.se);
    }
    set crosshairsAnnotationYAxisBackground(v) {
        this.i.se = stringToBrush(v);
    }
    /**
     * Gets or sets the text color of crosshair annotation on x-axis.
    */
    get crosshairsAnnotationXAxisTextColor() {
        return brushToString(this.i.sd);
    }
    set crosshairsAnnotationXAxisTextColor(v) {
        this.i.sd = stringToBrush(v);
    }
    /**
     * Gets or sets the text color of crosshair annotation on y-axis.
    */
    get crosshairsAnnotationYAxisTextColor() {
        return brushToString(this.i.sf);
    }
    set crosshairsAnnotationYAxisTextColor(v) {
        this.i.sf = stringToBrush(v);
    }
    /**
     * Gets or sets precision on interpolated values of crosshairs on x-axis.
    */
    get crosshairsAnnotationXAxisPrecision() {
        return this.i.ij;
    }
    set crosshairsAnnotationXAxisPrecision(v) {
        this.i.ij = +v;
    }
    /**
     * Gets or sets precision on interpolated values of crosshairs on y-axis.
    */
    get crosshairsAnnotationYAxisPrecision() {
        return this.i.ik;
    }
    set crosshairsAnnotationYAxisPrecision(v) {
        this.i.ik = +v;
    }
    /**
     * Gets or sets whether annotations for the final value of each series is displayed on the axis.
    */
    get shouldAvoidAxisAnnotationCollisions() {
        return this.i.e8;
    }
    set shouldAvoidAxisAnnotationCollisions(v) {
        this.i.e8 = ensureBool(v);
    }
    /**
     * Gets or sets whether annotations for the final value of each series is displayed on the axis.
    */
    get finalValueAnnotationsVisible() {
        return this.i.es;
    }
    set finalValueAnnotationsVisible(v) {
        this.i.es = ensureBool(v);
    }
    /**
     * Gets or sets the background of final value annotation.
    */
    get finalValueAnnotationsBackground() {
        return brushToString(this.i.sr);
    }
    set finalValueAnnotationsBackground(v) {
        this.i.sr = stringToBrush(v);
    }
    /**
     * Gets or sets the text color of final value annotation.
    */
    get finalValueAnnotationsTextColor() {
        return brushToString(this.i.ss);
    }
    set finalValueAnnotationsTextColor(v) {
        this.i.ss = stringToBrush(v);
    }
    /**
     * Gets or sets precision on final value annotation.
    */
    get finalValueAnnotationsPrecision() {
        return this.i.io;
    }
    set finalValueAnnotationsPrecision(v) {
        this.i.io = +v;
    }
    /**
     * Gets or sets if callouts should be displayed.
    */
    get calloutsVisible() {
        return this.i.ek;
    }
    set calloutsVisible(v) {
        this.i.ek = ensureBool(v);
    }
    /**
     * Gets or sets if event annotations should be displayed.
    */
    get calloutStyleUpdatingEventEnabled() {
        return this.i.ej;
    }
    set calloutStyleUpdatingEventEnabled(v) {
        this.i.ej = ensureBool(v);
    }
    /**
     * Gets or sets the allowed positions that the callout layer is allowed to use.
    */
    get calloutsAllowedPositions() {
        if (this._calloutsAllowedPositions === null) {
            let coll = new IgrCalloutPlacementPositionsCollection();
            let innerColl = this.i.ai;
            if (!innerColl) {
                innerColl = new CalloutPlacementPositionsCollection_internal();
            }
            this._calloutsAllowedPositions = coll._fromInner(innerColl);
            this.i.ai = innerColl;
        }
        return this._calloutsAllowedPositions;
    }
    set calloutsAllowedPositions(v) {
        if (this._calloutsAllowedPositions !== null) {
            this._calloutsAllowedPositions._setSyncTarget(null);
            this._calloutsAllowedPositions = null;
        }
        let coll = new IgrCalloutPlacementPositionsCollection();
        this._calloutsAllowedPositions = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(CalloutPlacementPositions_$type);
        let innerColl = this.i.ai;
        if (!innerColl) {
            innerColl = new CalloutPlacementPositionsCollection_internal();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._calloutsAllowedPositions._setSyncTarget(syncColl);
        this.i.ai = innerColl;
    }
    /**
     * Gets or sets the member path of the X data for the callouts.
    */
    get calloutsXMemberPath() {
        return this.i.j1;
    }
    set calloutsXMemberPath(v) {
        this.i.j1 = v;
    }
    /**
     * Gets or sets the member path of the Y data for the callouts.
    */
    get calloutsYMemberPath() {
        return this.i.j3;
    }
    set calloutsYMemberPath(v) {
        this.i.j3 = v;
    }
    /**
     * Gets or sets the member path of the label data for the callouts.
    */
    get calloutsLabelMemberPath() {
        return this.i.jx;
    }
    set calloutsLabelMemberPath(v) {
        this.i.jx = v;
    }
    /**
     * Gets or sets the member path of the content data for the callouts.
    */
    get calloutsContentMemberPath() {
        return this.i.ju;
    }
    set calloutsContentMemberPath(v) {
        this.i.ju = v;
    }
    /**
     * Gets or sets the horizontal scrollbar mode to use for the series viewer.
    */
    get horizontalViewScrollbarMode() {
        return this.i.cv;
    }
    set horizontalViewScrollbarMode(v) {
        this.i.cv = ensureEnum(SeriesViewerScrollbarMode_$type, v);
    }
    /**
     * Gets or sets the vertical scrollbar mode to use for the series viewer.
    */
    get verticalViewScrollbarMode() {
        return this.i.cw;
    }
    set verticalViewScrollbarMode(v) {
        this.i.cw = ensureEnum(SeriesViewerScrollbarMode_$type, v);
    }
    /**
     * Gets or sets the position to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarPosition() {
        return this.i.cs;
    }
    set horizontalViewScrollbarPosition(v) {
        this.i.cs = ensureEnum(SeriesViewerHorizontalScrollbarPosition_$type, v);
    }
    /**
     * Gets or sets the position to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarPosition() {
        return this.i.cy;
    }
    set verticalViewScrollbarPosition(v) {
        this.i.cy = ensureEnum(SeriesViewerVerticalScrollbarPosition_$type, v);
    }
    /**
     * Gets or sets the fill to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarFill() {
        return brushToString(this.i.sx);
    }
    set horizontalViewScrollbarFill(v) {
        this.i.sx = stringToBrush(v);
    }
    /**
     * Gets or sets the outline to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarOutline() {
        return brushToString(this.i.sy);
    }
    set horizontalViewScrollbarOutline(v) {
        this.i.sy = stringToBrush(v);
    }
    /**
     * Gets or sets the stroke thickness to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarStrokeThickness() {
        return this.i.hc;
    }
    set horizontalViewScrollbarStrokeThickness(v) {
        this.i.hc = +v;
    }
    /**
     * Gets or sets the max opacity to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarMaxOpacity() {
        return this.i.hb;
    }
    set horizontalViewScrollbarMaxOpacity(v) {
        this.i.hb = +v;
    }
    /**
     * Gets or sets the corner radius to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarCornerRadius() {
        return this.i.g8;
    }
    set horizontalViewScrollbarCornerRadius(v) {
        this.i.g8 = +v;
    }
    /**
     * Gets or sets the height to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarHeight() {
        return this.i.g9;
    }
    set horizontalViewScrollbarHeight(v) {
        this.i.g9 = +v;
    }
    /**
     * Gets or sets the inset distance to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarInset() {
        return this.i.ha;
    }
    set horizontalViewScrollbarInset(v) {
        this.i.ha = +v;
    }
    /**
     * Gets or sets the track start inset to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarTrackStartInset() {
        return this.i.he;
    }
    set horizontalViewScrollbarTrackStartInset(v) {
        this.i.he = +v;
    }
    /**
     * Gets or sets the track end inset to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarTrackEndInset() {
        return this.i.hd;
    }
    set horizontalViewScrollbarTrackEndInset(v) {
        this.i.hd = +v;
    }
    /**
     * Gets or sets whether to use automatic track insets for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarShouldAddAutoTrackInsets() {
        return this.i.eu;
    }
    set horizontalViewScrollbarShouldAddAutoTrackInsets(v) {
        this.i.eu = ensureBool(v);
    }
    /**
     * Gets or sets the fill to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarFill() {
        return brushToString(this.i.s2);
    }
    set verticalViewScrollbarFill(v) {
        this.i.s2 = stringToBrush(v);
    }
    /**
     * Gets or sets the outline to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarOutline() {
        return brushToString(this.i.s3);
    }
    set verticalViewScrollbarOutline(v) {
        this.i.s3 = stringToBrush(v);
    }
    /**
     * Gets or sets the stroke thickness to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarStrokeThickness() {
        return this.i.h3;
    }
    set verticalViewScrollbarStrokeThickness(v) {
        this.i.h3 = +v;
    }
    /**
     * Gets or sets the max opacity to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarMaxOpacity() {
        return this.i.h2;
    }
    set verticalViewScrollbarMaxOpacity(v) {
        this.i.h2 = +v;
    }
    /**
     * Gets or sets the corner radius to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarCornerRadius() {
        return this.i.h0;
    }
    set verticalViewScrollbarCornerRadius(v) {
        this.i.h0 = +v;
    }
    /**
     * Gets or sets the width to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarWidth() {
        return this.i.h6;
    }
    set verticalViewScrollbarWidth(v) {
        this.i.h6 = +v;
    }
    /**
     * Gets or sets the inset distance to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarInset() {
        return this.i.h1;
    }
    set verticalViewScrollbarInset(v) {
        this.i.h1 = +v;
    }
    /**
     * Gets or sets the track start inset to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarTrackStartInset() {
        return this.i.h5;
    }
    set verticalViewScrollbarTrackStartInset(v) {
        this.i.h5 = +v;
    }
    /**
     * Gets or sets the track end inset to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarTrackEndInset() {
        return this.i.h4;
    }
    set verticalViewScrollbarTrackEndInset(v) {
        this.i.h4 = +v;
    }
    /**
     * Gets or sets whether to use automatic track insets for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarShouldAddAutoTrackInsets() {
        return this.i.fb;
    }
    set verticalViewScrollbarShouldAddAutoTrackInsets(v) {
        this.i.fb = ensureBool(v);
    }
    findByName(name) {
        if (this.dataToolTipValueFormatSpecifiers != null && arrayFindByName(this.dataToolTipValueFormatSpecifiers, name)) {
            return arrayFindByName(this.dataToolTipValueFormatSpecifiers, name);
        }
        if (this.dataToolTipHeaderFormatSpecifiers != null && arrayFindByName(this.dataToolTipHeaderFormatSpecifiers, name)) {
            return arrayFindByName(this.dataToolTipHeaderFormatSpecifiers, name);
        }
        if (this.legend && this.legend.name && this.legend.name == name) {
            return this.legend;
        }
        if (this.markerTypes != null && this.markerTypes.findByName && this.markerTypes.findByName(name)) {
            return this.markerTypes.findByName(name);
        }
        if (this.calloutsAllowedPositions != null && this.calloutsAllowedPositions.findByName && this.calloutsAllowedPositions.findByName(name)) {
            return this.calloutsAllowedPositions.findByName(name);
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("DomainChart");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    /**
 * Provides a container for this control

*
* `provideContainer` method provide container for the control.
*
* ```ts
*     this.chart.provideContainer("Container");
* ```
*/
    provideContainer(container) {
        this.i.provideContainer(container);
    }
    /**
     * Destroy this control
    
    *
    * Use the `destroy` property to destroy the chart.
    *
    * ```ts
    * this.chart.destroy();
    * ```
    */
    destroy() {
        this.i.destroy();
    }
    /**
     * Called when the control has been resized.
    
    *
    * `notifyResized` method Called when the control has been resized.
    *
    * ```ts
    * this.chart.notifyResized();
    * ```
    */
    notifyResized() {
        this.i.notifyResized();
    }
    notifyVisualPropertiesChanged() {
        this.i.qj();
    }
    /**
     * Forces any pending refresh to the chart to be finished.
    
    *
    * Method `flush` used to Forces any pending deferred work to render on the chart before continuing.
    *
    * ```ts
    * this.chart.flush();
    * ```
    */
    flush() {
        this.i.pq();
    }
    /**
     * Hides the active main tooltip, if displayed.
    
    *
    * Use the `hideToolTip` method to hide the active tooltip.
    *
    * ```ts
    * this.chart.hideToolTip();
    * ```
    */
    hideToolTip() {
        this.i.py();
    }
    /**
     * Replays transition-in animation on all series in the chart.
    
    */
    replayTransitionIn() {
        this.i.ra();
    }
    notifySetItem(source_, index, oldItem, newItem) {
        this.i.qi(source_, index, oldItem, newItem);
    }
    /**
     * Used to manually notify the chart that the data source has reset or cleared its items.
    
    *
    * Use `notifyClearItems` method to notifies the chart that the items have been cleared from an associated data source.
    *
    * ```ts
    * this.chart.notifyClearItems(this.data);
    * ```
    */
    notifyClearItems(source_) {
        this.i.qe(source_);
    }
    notifyInsertItem(source_, index, newItem) {
        this.i.qf(source_, index, newItem);
    }
    notifyRemoveItem(source_, index, oldItem) {
        this.i.qg(source_, index, oldItem);
    }
    /**
     * Event raised when a series is initialized and added to this chart.
    *
    * `SeriesAdded` event raised when a series is initialized and added to this chart.
    *
    * ````ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	seriesAdded={this.CategoryChart_SeriesAdded}/>
    * ``
    *
    * ```ts
    * CategoryChart_SeriesAdded(sender:any ,aregs:ChartSeriesEventArgs)
    * {
    * }
    * ````
    */
    get seriesAdded() {
        return this._seriesAdded;
    }
    set seriesAdded(ev) {
        if (this._seriesAdded_wrapped !== null) {
            this.i.seriesAdded = delegateRemove(this.i.seriesAdded, this._seriesAdded_wrapped);
            this._seriesAdded_wrapped = null;
            this._seriesAdded = null;
        }
        this._seriesAdded = ev;
        this._seriesAdded_wrapped = (o, e) => {
            let outerArgs = new IgrChartSeriesEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSeriesAdded) {
                this.beforeSeriesAdded(this, outerArgs);
            }
            if (this._seriesAdded) {
                this._seriesAdded(this, outerArgs);
            }
        };
        this.i.seriesAdded = delegateCombine(this.i.seriesAdded, this._seriesAdded_wrapped);
        ;
    }
    /**
     * Event raised when a series is removed from this chart.
    *
    * `SeriesRemoved` event raised when a series is removed from this chart.
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	seriesRemoved={this.CategoryChart_seriesRemoved}/>
    * ```
    *
    * ```ts
    *  CategoryChart_seriesRemoved(sender: any , aregs: ChartSeriesEventArgs)
    *   {
    *
    *   }
    * ```
    */
    get seriesRemoved() {
        return this._seriesRemoved;
    }
    set seriesRemoved(ev) {
        if (this._seriesRemoved_wrapped !== null) {
            this.i.seriesRemoved = delegateRemove(this.i.seriesRemoved, this._seriesRemoved_wrapped);
            this._seriesRemoved_wrapped = null;
            this._seriesRemoved = null;
        }
        this._seriesRemoved = ev;
        this._seriesRemoved_wrapped = (o, e) => {
            let outerArgs = new IgrChartSeriesEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSeriesRemoved) {
                this.beforeSeriesRemoved(this, outerArgs);
            }
            if (this._seriesRemoved) {
                this._seriesRemoved(this, outerArgs);
            }
        };
        this.i.seriesRemoved = delegateCombine(this.i.seriesRemoved, this._seriesRemoved_wrapped);
        ;
    }
    /**
     * Occurs when the pointer enters a Series.
    *
    * `SeriesPointerEnter` event raised when the pointer enters a Series.
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	seriesPointerEnter={this.CategoryChart_seriesPointerDown}/>
    * ```
    *
    * ```ts
    * CategoryChart_seriesPointerEnter(sender: any , aregs: ChartSeriesEventArgs)
    *   {
    *
    *   }
    * ```
    */
    get seriesPointerEnter() {
        return this._seriesPointerEnter;
    }
    set seriesPointerEnter(ev) {
        if (this._seriesPointerEnter_wrapped !== null) {
            this.i.seriesPointerEnter = delegateRemove(this.i.seriesPointerEnter, this._seriesPointerEnter_wrapped);
            this._seriesPointerEnter_wrapped = null;
            this._seriesPointerEnter = null;
        }
        this._seriesPointerEnter = ev;
        this._seriesPointerEnter_wrapped = (o, e) => {
            let outerArgs = new IgrDomainChartSeriesPointerEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSeriesPointerEnter) {
                this.beforeSeriesPointerEnter(this, outerArgs);
            }
            if (this._seriesPointerEnter) {
                this._seriesPointerEnter(this, outerArgs);
            }
        };
        this.i.seriesPointerEnter = delegateCombine(this.i.seriesPointerEnter, this._seriesPointerEnter_wrapped);
        ;
    }
    /**
     * Occurs when the pointer leaves a Series.
    *
    * `SeriesPointerLeave` event raised when the pointer leaves a Series.
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	seriesPointerLeave={this.CategoryChart_seriesPointerLeave}/>
    * ```
    *
    * ```ts
    * CategoryChart_seriesPointerLeave(sender: any , aregs: ChartSeriesEventArgs)
    *   {
    *
    *   }
    * ```
    */
    get seriesPointerLeave() {
        return this._seriesPointerLeave;
    }
    set seriesPointerLeave(ev) {
        if (this._seriesPointerLeave_wrapped !== null) {
            this.i.seriesPointerLeave = delegateRemove(this.i.seriesPointerLeave, this._seriesPointerLeave_wrapped);
            this._seriesPointerLeave_wrapped = null;
            this._seriesPointerLeave = null;
        }
        this._seriesPointerLeave = ev;
        this._seriesPointerLeave_wrapped = (o, e) => {
            let outerArgs = new IgrDomainChartSeriesPointerEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSeriesPointerLeave) {
                this.beforeSeriesPointerLeave(this, outerArgs);
            }
            if (this._seriesPointerLeave) {
                this._seriesPointerLeave(this, outerArgs);
            }
        };
        this.i.seriesPointerLeave = delegateCombine(this.i.seriesPointerLeave, this._seriesPointerLeave_wrapped);
        ;
    }
    /**
     * Occurs when the pointer moves over a Series.
    *
    * `SeriesPointerMove` event raised when the pointer moves over a Series.
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	seriesPointerMove={this.CategoryChart_seriesPointerMove}/>
    * ```
    *
    * ```ts
    *  CategoryChart_seriesPointerMove(sender: any , aregs: ChartSeriesEventArgs)
    *   {
    *
    *   }
    * ```
    */
    get seriesPointerMove() {
        return this._seriesPointerMove;
    }
    set seriesPointerMove(ev) {
        if (this._seriesPointerMove_wrapped !== null) {
            this.i.seriesPointerMove = delegateRemove(this.i.seriesPointerMove, this._seriesPointerMove_wrapped);
            this._seriesPointerMove_wrapped = null;
            this._seriesPointerMove = null;
        }
        this._seriesPointerMove = ev;
        this._seriesPointerMove_wrapped = (o, e) => {
            let outerArgs = new IgrDomainChartSeriesPointerEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSeriesPointerMove) {
                this.beforeSeriesPointerMove(this, outerArgs);
            }
            if (this._seriesPointerMove) {
                this._seriesPointerMove(this, outerArgs);
            }
        };
        this.i.seriesPointerMove = delegateCombine(this.i.seriesPointerMove, this._seriesPointerMove_wrapped);
        ;
    }
    /**
     * Occurs when the pointer is pressed down over a Series.
    *
    * `SeriesPointerDown` event raised when the pointer is pressed down over a Series
    *
    * ````ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	seriesPointerDown={this.CategoryChart_seriesPointerDown}/>
    * ``
    *
    * ```ts
    * CategoryChart_seriesPointerDown(sender: any , aregs: ChartSeriesEventArgs)
    *   {
    *
    *   }
    * ````
    */
    get seriesPointerDown() {
        return this._seriesPointerDown;
    }
    set seriesPointerDown(ev) {
        if (this._seriesPointerDown_wrapped !== null) {
            this.i.seriesPointerDown = delegateRemove(this.i.seriesPointerDown, this._seriesPointerDown_wrapped);
            this._seriesPointerDown_wrapped = null;
            this._seriesPointerDown = null;
        }
        this._seriesPointerDown = ev;
        this._seriesPointerDown_wrapped = (o, e) => {
            let outerArgs = new IgrDomainChartSeriesPointerEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSeriesPointerDown) {
                this.beforeSeriesPointerDown(this, outerArgs);
            }
            if (this._seriesPointerDown) {
                this._seriesPointerDown(this, outerArgs);
            }
        };
        this.i.seriesPointerDown = delegateCombine(this.i.seriesPointerDown, this._seriesPointerDown_wrapped);
        ;
    }
    /**
     * Occurs when the pointer is released over a Series.
    *
    * `SeriesPointerUp` event raised when the pointer is released over a Series.
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	seriesPointerUp={this.CategoryChart_seriesPointerUp}/>
    * ```
    *
    * ```ts
    *  CategoryChart_seriesPointerUp(sender: any , aregs: ChartSeriesEventArgs)
    *   {
    *
    *   }
    * ```
    */
    get seriesPointerUp() {
        return this._seriesPointerUp;
    }
    set seriesPointerUp(ev) {
        if (this._seriesPointerUp_wrapped !== null) {
            this.i.seriesPointerUp = delegateRemove(this.i.seriesPointerUp, this._seriesPointerUp_wrapped);
            this._seriesPointerUp_wrapped = null;
            this._seriesPointerUp = null;
        }
        this._seriesPointerUp = ev;
        this._seriesPointerUp_wrapped = (o, e) => {
            let outerArgs = new IgrDomainChartSeriesPointerEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSeriesPointerUp) {
                this.beforeSeriesPointerUp(this, outerArgs);
            }
            if (this._seriesPointerUp) {
                this._seriesPointerUp(this, outerArgs);
            }
        };
        this.i.seriesPointerUp = delegateCombine(this.i.seriesPointerUp, this._seriesPointerUp_wrapped);
        ;
    }
    /**
     * Occurs when the style of a callout is updated.
    */
    get calloutStyleUpdating() {
        return this._calloutStyleUpdating;
    }
    set calloutStyleUpdating(ev) {
        if (this._calloutStyleUpdating_wrapped !== null) {
            this.i.calloutStyleUpdating = delegateRemove(this.i.calloutStyleUpdating, this._calloutStyleUpdating_wrapped);
            this._calloutStyleUpdating_wrapped = null;
            this._calloutStyleUpdating = null;
        }
        this._calloutStyleUpdating = ev;
        this._calloutStyleUpdating_wrapped = (o, e) => {
            let outerArgs = new IgrCalloutStyleUpdatingEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCalloutStyleUpdating) {
                this.beforeCalloutStyleUpdating(this, outerArgs);
            }
            if (this._calloutStyleUpdating) {
                this._calloutStyleUpdating(this, outerArgs);
            }
        };
        this.i.calloutStyleUpdating = delegateCombine(this.i.calloutStyleUpdating, this._calloutStyleUpdating_wrapped);
        ;
    }
    /**
     * Occurs when the style of a callout is updated.
    */
    get calloutRenderStyleUpdating() {
        return this._calloutRenderStyleUpdating;
    }
    set calloutRenderStyleUpdating(ev) {
        if (this._calloutRenderStyleUpdating_wrapped !== null) {
            this.i.calloutRenderStyleUpdating = delegateRemove(this.i.calloutRenderStyleUpdating, this._calloutRenderStyleUpdating_wrapped);
            this._calloutRenderStyleUpdating_wrapped = null;
            this._calloutRenderStyleUpdating = null;
        }
        this._calloutRenderStyleUpdating = ev;
        this._calloutRenderStyleUpdating_wrapped = (o, e) => {
            let outerArgs = new IgrCalloutRenderStyleUpdatingEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCalloutRenderStyleUpdating) {
                this.beforeCalloutRenderStyleUpdating(this, outerArgs);
            }
            if (this._calloutRenderStyleUpdating) {
                this._calloutRenderStyleUpdating(this, outerArgs);
            }
        };
        this.i.calloutRenderStyleUpdating = delegateCombine(this.i.calloutRenderStyleUpdating, this._calloutRenderStyleUpdating_wrapped);
        ;
    }
}
