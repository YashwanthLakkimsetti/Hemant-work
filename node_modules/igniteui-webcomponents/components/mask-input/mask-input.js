var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html } from 'lit';
import { property, state } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { live } from 'lit/directives/live.js';
import { watch } from '../common/decorators/watch.js';
import { blazorTwoWayBind } from '../common/decorators/blazorTwoWayBind.js';
import { partNameMap } from '../common/util.js';
import { IgcInputBaseComponent } from '../input/input-base.js';
import { MaskParser } from './mask-parser.js';
export default class IgcMaskInputComponent extends IgcInputBaseComponent {
    constructor() {
        super(...arguments);
        this.parser = new MaskParser();
        this._value = '';
        this.selection = { start: 0, end: 0 };
        this.compositionStart = 0;
        this.hasFocus = false;
        this.maskedValue = '';
        this.dir = 'auto';
        this.invalid = false;
        this.valueMode = 'raw';
    }
    get inputSelection() {
        return {
            start: this.input.selectionStart || 0,
            end: this.input.selectionEnd || 0,
        };
    }
    get value() {
        return this._value
            ? this.valueMode !== 'raw'
                ? this.maskedValue
                : this._value
            : this._value;
    }
    set value(string) {
        this._value = string !== null && string !== void 0 ? string : '';
        this.maskedValue = this.parser.apply(this._value);
    }
    promptChange() {
        this.parser.prompt = this.prompt;
        if (this.value) {
            this.maskedValue = this.parser.apply(this._value);
        }
    }
    maskChange() {
        this.parser.mask = this.mask;
        if (this.value) {
            this.maskedValue = this.parser.apply(this._value);
        }
    }
    handleInvalidState() {
        this.updateComplete.then(() => (this.invalid = !this.checkValidity()));
    }
    connectedCallback() {
        super.connectedCallback();
        this.mask = this.mask || this.parser.mask;
        this.prompt = this.prompt || this.parser.prompt;
    }
    handleKeydown(e) {
        if (!e.key) {
            return;
        }
        this.selection = this.inputSelection;
    }
    handleCompositionStart() {
        this.compositionStart = this.inputSelection.start;
    }
    handleCompositionEnd({ data }) {
        const start = this.compositionStart, end = this.inputSelection.end;
        this.updateInput(data, start, end);
    }
    handleInput({ inputType, isComposing }) {
        const value = this.input.value;
        const start = this.selection.start;
        let end = this.selection.end;
        switch (inputType) {
            case 'deleteContentForward':
                this.updateInput('', start, (end = start === end ? ++end : end));
                return this.updateComplete.then(() => this.input.setSelectionRange(end, end));
            case 'deleteContentBackward':
                if (isComposing)
                    return;
                return this.updateInput('', this.inputSelection.start, end);
            case 'deleteByCut':
                return this.updateInput('', start, end);
            case 'insertText':
                return this.updateInput(value.substring(start, this.inputSelection.end), start, end);
            case 'insertFromPaste':
                return this.updateInput(value.substring(start, this.inputSelection.end), start, this.inputSelection.start);
            case 'insertFromDrop':
                return this.updateInput(value.substring(this.inputSelection.start, this.inputSelection.end), this.inputSelection.start, this.inputSelection.end);
        }
    }
    updateInput(part, start, finish) {
        const { value, end } = this.parser.replace(this.maskedValue, part, start, finish);
        this.maskedValue = value;
        this._value = this.parser.parse(value);
        this.requestUpdate();
        if (start !== this.mask.length) {
            this.emitEvent('igcInput', { detail: this.value });
        }
        this.updateComplete.then(() => this.input.setSelectionRange(end, end));
    }
    handleCut() {
        this.selection = this.inputSelection;
    }
    handleDragStart() {
        this.selection = this.inputSelection;
    }
    handleDragEnter() {
        if (!this.hasFocus && !this._value) {
            this.maskedValue = this.parser.apply();
        }
    }
    handleDragLeave() {
        if (!this.hasFocus) {
            this.updateMaskedValue();
        }
    }
    handleFocus() {
        this.hasFocus = true;
        super.handleFocus();
        if (this.readonly) {
            return;
        }
        if (!this._value) {
            this.maskedValue = this.parser.apply();
            this.updateComplete.then(() => this.select());
        }
    }
    handleBlur() {
        this.hasFocus = false;
        this.updateMaskedValue();
        super.handleBlur();
    }
    handleChange() {
        this.emitEvent('igcChange', { detail: this.value });
        this.invalid = !this.checkValidity();
    }
    handleInvalid() {
        this.invalid = true;
    }
    handleClick() {
        if (this.input.selectionStart === this.input.selectionEnd &&
            this.input.selectionStart === this.maskedValue.length) {
            this.select();
        }
    }
    updateMaskedValue() {
        if (this.maskedValue === this.parser.apply()) {
            this.maskedValue = '';
        }
    }
    setRangeText(replacement, start, end, _selectMode = 'preserve') {
        this.input.value = this.parser.replace(this.input.value, replacement, start, end).value;
        this.maskedValue = this.parser.apply(this.parser.parse(this.input.value));
        this._value = this.parser.parse(this.maskedValue);
    }
    setSelectionRange(start, end, direction) {
        super.setSelectionRange(start, end, direction);
        this.selection = { start, end };
    }
    reportValidity() {
        const state = this._value
            ? this.parser.isValidString(this.input.value)
            : this.input.reportValidity();
        this.invalid = !state;
        return state;
    }
    setCustomValidity(message) {
        this.input.setCustomValidity(message);
        this.invalid = !this.input.checkValidity();
    }
    checkValidity() {
        if (this.disabled) {
            return this.input.checkValidity();
        }
        if (!this._value) {
            return !this.required;
        }
        return (this.input.checkValidity() && this.parser.isValidString(this.input.value));
    }
    select() {
        this.input.select();
    }
    renderInput() {
        var _a;
        return html `
      <input
        type="text"
        part=${partNameMap(this.resolvePartNames('input'))}
        name=${ifDefined(this.name)}
        .value=${live(this.maskedValue)}
        .placeholder=${live((_a = this.placeholder) !== null && _a !== void 0 ? _a : this.parser.escapedMask)}
        ?readonly=${this.readonly}
        ?disabled=${this.disabled}
        ?required=${this.required}
        @dragenter=${this.handleDragEnter}
        @dragleave=${this.handleDragLeave}
        @dragstart=${this.handleDragStart}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @cut=${this.handleCut}
        @change=${this.handleChange}
        @click=${this.handleClick}
        @compositionstart=${this.handleCompositionStart}
        @compositionend=${this.handleCompositionEnd}
        @input=${this.handleInput}
        aria-invalid="${this.invalid ? 'true' : 'false'}"
        @invalid="${this.handleInvalid}"
        @keydown=${this.handleKeydown}
      />
    `;
    }
}
IgcMaskInputComponent.tagName = 'igc-mask-input';
__decorate([
    state()
], IgcMaskInputComponent.prototype, "hasFocus", void 0);
__decorate([
    state()
], IgcMaskInputComponent.prototype, "maskedValue", void 0);
__decorate([
    property({ reflect: true })
], IgcMaskInputComponent.prototype, "dir", void 0);
__decorate([
    property({ reflect: true, type: Boolean })
], IgcMaskInputComponent.prototype, "invalid", void 0);
__decorate([
    property({ attribute: 'value-mode' })
], IgcMaskInputComponent.prototype, "valueMode", void 0);
__decorate([
    property(),
    blazorTwoWayBind('igcChange', 'detail')
], IgcMaskInputComponent.prototype, "value", null);
__decorate([
    property()
], IgcMaskInputComponent.prototype, "mask", void 0);
__decorate([
    property()
], IgcMaskInputComponent.prototype, "prompt", void 0);
__decorate([
    watch('prompt')
], IgcMaskInputComponent.prototype, "promptChange", null);
__decorate([
    watch('mask')
], IgcMaskInputComponent.prototype, "maskChange", null);
__decorate([
    watch('required', { waitUntilFirstUpdate: true }),
    watch('disabled', { waitUntilFirstUpdate: true }),
    watch('value', { waitUntilFirstUpdate: true })
], IgcMaskInputComponent.prototype, "handleInvalidState", null);
//# sourceMappingURL=mask-input.js.map