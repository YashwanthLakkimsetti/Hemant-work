var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html, LitElement, nothing } from 'lit';
import { property, query, queryAssignedElements, state, } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { watch } from '../common/decorators/watch.js';
import { EventEmitterMixin } from '../common/mixins/event-emitter.js';
import { SizableMixin } from '../common/mixins/sizable.js';
import { styles } from './rating.base.css.js';
import { styles as bootstrap } from './rating.bootstrap.css.js';
import { styles as fluent } from './rating.fluent.css.js';
import { styles as indigo } from './rating.indigo.css.js';
import { clamp } from '../common/util.js';
import { themes } from '../../theming/theming-decorator.js';
let IgcRatingComponent = class IgcRatingComponent extends SizableMixin(EventEmitterMixin(LitElement)) {
    constructor() {
        super();
        this.hoverValue = -1;
        this.hoverState = false;
        this.max = 5;
        this.step = 1;
        this.symbol = '⭐';
        this.value = 0;
        this.disabled = false;
        this.hoverPreview = false;
        this.readonly = false;
        this.addEventListener('keydown', this.handleKeyDown);
    }
    get isInteractive() {
        return !(this.readonly || this.disabled);
    }
    get hasProjectedSymbols() {
        return this.ratingSymbols.length > 0;
    }
    get isLTR() {
        return (window.getComputedStyle(this).getPropertyValue('direction') === 'ltr');
    }
    get valueText() {
        return this.valueFormat
            ? this.valueFormat.replace(/\{0\}/gm, `${this.value}`)
            : this.value;
    }
    handleMaxChange() {
        this.hasProjectedSymbols
            ? (this.max = this.ratingSymbols.length)
            : (this.max = Math.max(0, this.max));
        if (this.max < this.value) {
            this.value = this.max;
        }
    }
    handleValueChange() {
        this.value = clamp(this.value, 0, this.max);
    }
    handlePrecisionChange() {
        this.step = clamp(this.step, 0.001, 1);
    }
    handleClick({ clientX }) {
        if (!this.isInteractive) {
            return;
        }
        const value = this.calcNewValue(clientX);
        this.value === value ? (this.value = 0) : (this.value = value);
        this.emitEvent('igcChange', { detail: this.value });
    }
    handleMouseMove({ clientX }) {
        if (!this.isInteractive) {
            return;
        }
        const value = this.calcNewValue(clientX);
        if (this.hoverValue !== value) {
            this.hoverValue = value;
            this.emitEvent('igcHover', { detail: this.hoverValue });
        }
    }
    handleMouseEnter() {
        if (this.isInteractive) {
            this.hoverState = true;
        }
    }
    handleMouseLeave() {
        if (this.isInteractive) {
            this.hoverState = false;
        }
    }
    handleKeyDown({ key }) {
        if (!this.isInteractive) {
            return;
        }
        let result = this.value;
        switch (key) {
            case 'ArrowUp':
            case 'ArrowRight':
                result += this.isLTR ? this.step : -this.step;
                break;
            case 'ArrowDown':
            case 'ArrowLeft':
                result -= this.isLTR ? this.step : -this.step;
                break;
            case 'Home':
                result = this.step;
                break;
            case 'End':
                result = this.max;
                break;
            default:
                return;
        }
        this.value = clamp(result, 0, this.max);
        if (result === this.value) {
            this.emitEvent('igcChange', { detail: this.value });
        }
    }
    handleSlotChange() {
        if (this.hasProjectedSymbols) {
            this.max = this.ratingSymbols.length;
        }
        this.requestUpdate();
    }
    calcNewValue(x) {
        const { width, left, right } = this.container.getBoundingClientRect();
        const percent = this.isLTR ? (x - left) / width : (right - x) / width;
        const value = this.round(this.max * percent + this.step / 2);
        return clamp(value, this.step, this.max);
    }
    getPrecision(num) {
        const [_, decimal] = num.toString().split('.');
        return decimal ? decimal.length : 0;
    }
    round(value) {
        value = Math.round(value / this.step) * this.step;
        return Number(value.toFixed(this.getPrecision(this.step)));
    }
    stepUp(n = 1) {
        this.value += this.round(n * this.step);
    }
    stepDown(n = 1) {
        this.value -= this.round(n * this.step);
    }
    *renderSymbols() {
        for (let i = 0; i < this.max; i++) {
            yield html `<span part="symbol ${this.size}">${this.symbol}</span>`;
        }
    }
    renderProjected() {
        return html `${this.ratingSymbols.map((each) => {
            const clone = each.cloneNode(true);
            clone.setAttribute('part', `symbol ${this.size}`);
            return clone;
        })}`;
    }
    renderFractionWrapper(styles) {
        return html `<div
      @click=${this.handleClick}
      @mouseenter=${this.hoverPreview ? this.handleMouseEnter : nothing}
      @mouseleave=${this.hoverPreview ? this.handleMouseLeave : nothing}
      @mousemove=${this.hoverPreview ? this.handleMouseMove : nothing}
    >
      <slot @slotchange=${this.handleSlotChange}></slot>

      <div style=${styleMap(styles)} part="fraction ${this.size}">
        <div part="symbols-wrapper selected">
          ${this.hasProjectedSymbols
            ? this.renderProjected()
            : this.renderSymbols()}
        </div>
      </div>
      <div part="symbols-wrapper">
        ${this.hasProjectedSymbols
            ? this.renderProjected()
            : this.renderSymbols()}
      </div>
    </div>`;
    }
    render() {
        var _a;
        const value = this.hoverState ? this.hoverValue : this.value;
        const styles = { width: `${Math.round((value / this.max) * 100)}%` };
        return html `
      <label part="label ${this.size}">${this.label}</label>
      <div
        part="base"
        role="slider"
        tabindex=${ifDefined(this.disabled ? undefined : 0)}
        aria-label=${(_a = this.label) !== null && _a !== void 0 ? _a : nothing}
        aria-valuemin="0"
        aria-valuenow=${this.value}
        aria-valuemax=${this.max}
        aria-valuetext=${this.valueText}
      >
        ${this.renderFractionWrapper(styles)}
      </div>
    `;
    }
};
IgcRatingComponent.tagName = 'igc-rating';
IgcRatingComponent.styles = [styles];
__decorate([
    query('[part="base"]', true)
], IgcRatingComponent.prototype, "container", void 0);
__decorate([
    queryAssignedElements({ selector: 'igc-rating-symbol' })
], IgcRatingComponent.prototype, "ratingSymbols", void 0);
__decorate([
    state()
], IgcRatingComponent.prototype, "hoverValue", void 0);
__decorate([
    state()
], IgcRatingComponent.prototype, "hoverState", void 0);
__decorate([
    property({ type: Number })
], IgcRatingComponent.prototype, "max", void 0);
__decorate([
    property({ type: Number })
], IgcRatingComponent.prototype, "step", void 0);
__decorate([
    property()
], IgcRatingComponent.prototype, "symbol", void 0);
__decorate([
    property()
], IgcRatingComponent.prototype, "name", void 0);
__decorate([
    property()
], IgcRatingComponent.prototype, "label", void 0);
__decorate([
    property({ attribute: 'value-format' })
], IgcRatingComponent.prototype, "valueFormat", void 0);
__decorate([
    property({ type: Number })
], IgcRatingComponent.prototype, "value", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], IgcRatingComponent.prototype, "disabled", void 0);
__decorate([
    property({ type: Boolean, reflect: true, attribute: 'hover-preview' })
], IgcRatingComponent.prototype, "hoverPreview", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], IgcRatingComponent.prototype, "readonly", void 0);
__decorate([
    watch('max')
], IgcRatingComponent.prototype, "handleMaxChange", null);
__decorate([
    watch('value')
], IgcRatingComponent.prototype, "handleValueChange", null);
__decorate([
    watch('step')
], IgcRatingComponent.prototype, "handlePrecisionChange", null);
IgcRatingComponent = __decorate([
    themes({ fluent, bootstrap, indigo })
], IgcRatingComponent);
export default IgcRatingComponent;
//# sourceMappingURL=rating.js.map