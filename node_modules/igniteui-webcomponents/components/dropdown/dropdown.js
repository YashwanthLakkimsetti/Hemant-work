var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html, LitElement } from 'lit';
import { property, query, queryAssignedElements } from 'lit/decorators.js';
import { EventEmitterMixin } from '../common/mixins/event-emitter.js';
import { styles } from './themes/light/dropdown.base.css.js';
import { styles as bootstrap } from './themes/light/dropdown.bootstrap.css.js';
import { styles as fluent } from './themes/light/dropdown.fluent.css.js';
import { styles as indigo } from './themes/light/dropdown.indigo.css.js';
import IgcDropdownItemComponent from './dropdown-item.js';
import { IgcToggleController } from '../toggle/toggle.controller.js';
import { styleMap } from 'lit/directives/style-map.js';
import { SizableMixin } from '../common/mixins/sizable.js';
import { themes } from '../../theming/theming-decorator.js';
import { watch } from '../common/decorators/watch.js';
import { blazorSuppress } from '../common/decorators/blazorSuppress.js';
export var DropdownActionKey;
(function (DropdownActionKey) {
    DropdownActionKey["ESCAPE"] = "escape";
    DropdownActionKey["ENTER"] = "enter";
})(DropdownActionKey || (DropdownActionKey = {}));
let IgcDropdownComponent = class IgcDropdownComponent extends SizableMixin(EventEmitterMixin(LitElement)) {
    constructor() {
        super();
        this.keepOpenOnSelect = false;
        this.open = false;
        this.placement = 'bottom-start';
        this.positionStrategy = 'absolute';
        this.scrollStrategy = 'scroll';
        this.flip = false;
        this.distance = 0;
        this.keepOpenOnOutsideClick = false;
        this.sameWidth = false;
        this.handleKeyDown = (event) => {
            if (this.open &&
                event &&
                (event.composedPath().includes(this.target) ||
                    event.composedPath().includes(this.content))) {
                const key = event.key.toLowerCase();
                const navKeys = [
                    'esc',
                    'escape',
                    'enter',
                    'arrowup',
                    'up',
                    'arrowdown',
                    'down',
                ];
                if (navKeys.indexOf(key) === -1) {
                    return;
                }
                event.preventDefault();
                event.stopPropagation();
                switch (key) {
                    case 'esc':
                    case 'escape':
                        this.handleItemActionKey(DropdownActionKey.ESCAPE);
                        break;
                    case 'enter':
                        this.handleItemActionKey(DropdownActionKey.ENTER);
                        break;
                    case 'arrowup':
                    case 'up':
                        this.onArrowUpKeyDown();
                        break;
                    case 'arrowdown':
                    case 'down':
                        this.onArrowDownKeyDown();
                        break;
                    default:
                        return;
                }
            }
        };
        this.handleTargetClick = () => {
            if (!this.open) {
                if (!this.handleOpening())
                    return;
                this.show();
                this.emitEvent('igcOpened');
            }
            else {
                this._hide();
            }
        };
        this.toggleController = new IgcToggleController(this, this.target);
    }
    get allItems() {
        const groupItems = this.groups.flatMap((group) => group.items);
        return [...this.items, ...groupItems];
    }
    toggleDirectiveChange() {
        var _a;
        if (!this.target)
            return;
        this.toggleController.target = this.target;
        if (this.open) {
            document.addEventListener('keydown', this.handleKeyDown);
            this.target.addEventListener('focusout', this.handleFocusout);
            this.selectedItem = (_a = this.allItems.find((i) => i.selected)) !== null && _a !== void 0 ? _a : null;
        }
        else {
            document.removeEventListener('keydown', this.handleKeyDown);
            this.target.removeEventListener('focusout', this.handleFocusout);
        }
        this.target.setAttribute('aria-expanded', this.open ? 'true' : 'false');
    }
    updateOptions() {
        if (!this.toggleController)
            return;
        this.toggleController.updateToggleDir();
    }
    sizeChange() {
        this.groups.forEach((g) => (g.size = this.size));
    }
    firstUpdated() {
        if (this.targetNodes.length) {
            this.target = this.targetNodes[0];
            this.target.setAttribute('aria-haspopup', 'listbox');
        }
    }
    async getUpdateComplete() {
        const result = await super.getUpdateComplete();
        await this.toggleController.rendered;
        return result;
    }
    handleItemActionKey(key) {
        switch (key) {
            case DropdownActionKey.ENTER:
                this.selectItem(this.activeItem);
                this.handleChange(this.activeItem);
                break;
            case DropdownActionKey.ESCAPE:
                break;
        }
        if (!this.keepOpenOnSelect)
            this._hide();
    }
    handleClick(event) {
        const newSelectedItem = event
            .composedPath()
            .find((e) => e instanceof IgcDropdownItemComponent);
        if (!newSelectedItem || newSelectedItem.disabled)
            return;
        this.selectItem(newSelectedItem);
        this.handleChange(newSelectedItem);
        if (!this.keepOpenOnSelect)
            this._hide();
    }
    handleOpening() {
        const args = { cancelable: true };
        return this.emitEvent('igcOpening', args);
    }
    handleClosing() {
        const args = { cancelable: true };
        return this.emitEvent('igcClosing', args);
    }
    handleChange(item) {
        const args = { detail: item };
        this.emitEvent('igcChange', args);
    }
    handleSlotChange() {
        if (!this.target)
            return;
        this.target.setAttribute('aria-expanded', this.open ? 'true' : 'false');
    }
    handleFocusout(event) {
        event.preventDefault();
        event.target.focus();
    }
    getItem(value) {
        let itemIndex = -1;
        let item;
        this.allItems.find((i, index) => {
            if (i.value === value) {
                item = i;
                itemIndex = index;
            }
        });
        return { item: item, index: itemIndex };
    }
    activateItem(value) {
        if (!value)
            return;
        if (this.activeItem && this.activeItem !== value) {
            this.activeItem.active = false;
        }
        this.activeItem = value;
        this.activeItem.active = true;
    }
    selectItem(item, emit = true) {
        const oldItem = this.selectedItem;
        if (!item) {
            return null;
        }
        if (oldItem && oldItem !== item) {
            oldItem.selected = false;
        }
        this.activateItem(item);
        this.selectedItem = item;
        this.selectedItem.selected = true;
        if (emit)
            this.handleChange(this.selectedItem);
        return this.selectedItem;
    }
    navigate(direction, currentIndex) {
        var _a;
        let index = -1;
        if (this.activeItem) {
            index = currentIndex
                ? currentIndex
                : (_a = [...this.allItems].indexOf(this.activeItem)) !== null && _a !== void 0 ? _a : index;
        }
        const newIndex = this.getNearestSiblingFocusableItemIndex(index, direction);
        this.navigateItem(newIndex);
    }
    navigateItem(newIndex) {
        if (!this.allItems) {
            return null;
        }
        if (newIndex < 0 || newIndex >= this.allItems.length) {
            return null;
        }
        const newItem = this.allItems[newIndex];
        this.activateItem(newItem);
        this.scrollToHiddenItem(newItem);
        return newItem;
    }
    scrollToHiddenItem(newItem) {
        const elementRect = newItem.getBoundingClientRect();
        const parentRect = this.content.getBoundingClientRect();
        if (parentRect.top > elementRect.top) {
            this.content.scrollTop -= parentRect.top - elementRect.top;
        }
        if (parentRect.bottom < elementRect.bottom) {
            this.content.scrollTop += elementRect.bottom - parentRect.bottom;
        }
    }
    getNearestSiblingFocusableItemIndex(startIndex, direction) {
        let index = startIndex;
        const items = this.allItems;
        if (!items) {
            return -1;
        }
        while (items[index + direction] && items[index + direction].disabled) {
            index += direction;
        }
        index += direction;
        return index > -1 && index < items.length ? index : -1;
    }
    navigateNext() {
        this.navigate(1);
    }
    navigatePrev() {
        this.navigate(-1);
    }
    onArrowDownKeyDown() {
        this.navigateNext();
    }
    onArrowUpKeyDown() {
        this.navigatePrev();
    }
    _hide(emit = true) {
        if (emit && !this.handleClosing())
            return;
        if (!this.open)
            return;
        this.open = false;
        if (emit) {
            this.emitEvent('igcClosed');
        }
    }
    show(target) {
        if (this.open && !target)
            return;
        if (target)
            this.target = target;
        this.open = true;
    }
    hide() {
        this._hide(false);
    }
    toggle(target) {
        if (!this.open) {
            this.show(target);
        }
        else {
            this.hide();
        }
    }
    navigateTo(value) {
        const index = typeof value === 'string' ? this.getItem(value).index : value;
        return this.navigateItem(index);
    }
    select(value) {
        const item = typeof value === 'string'
            ? this.getItem(value).item
            : this.allItems[value];
        return this.selectItem(item, false);
    }
    clearSelection() {
        if (this.selectedItem) {
            this.selectedItem.selected = false;
        }
        this.selectedItem = null;
    }
    render() {
        return html `
      <slot
        id="igcDDLTarget"
        name="target"
        @click=${this.handleTargetClick}
        @slotchange=${this.handleSlotChange}
      >
      </slot>
      <div
        part="base"
        style=${styleMap({ position: this.positionStrategy })}
        @click=${this.handleClick}
        ${this.toggleController.toggleDirective}
      >
        <div role="listbox" part="list" aria-labelledby="igcDDLTarget">
          <slot></slot>
        </div>
      </div>
    `;
    }
};
IgcDropdownComponent.tagName = 'igc-dropdown';
IgcDropdownComponent.styles = styles;
__decorate([
    queryAssignedElements({ slot: 'target' })
], IgcDropdownComponent.prototype, "targetNodes", void 0);
__decorate([
    query('[part="base"]')
], IgcDropdownComponent.prototype, "content", void 0);
__decorate([
    query('[part="list"]')
], IgcDropdownComponent.prototype, "scrollContainer", void 0);
__decorate([
    queryAssignedElements({ flatten: true, selector: 'igc-dropdown-item' })
], IgcDropdownComponent.prototype, "items", void 0);
__decorate([
    queryAssignedElements({ flatten: true, selector: 'igc-dropdown-group' })
], IgcDropdownComponent.prototype, "groups", void 0);
__decorate([
    property({ type: Boolean, attribute: 'keep-open-on-select' })
], IgcDropdownComponent.prototype, "keepOpenOnSelect", void 0);
__decorate([
    property({ type: Boolean })
], IgcDropdownComponent.prototype, "open", void 0);
__decorate([
    property()
], IgcDropdownComponent.prototype, "placement", void 0);
__decorate([
    property({ attribute: 'position-strategy' })
], IgcDropdownComponent.prototype, "positionStrategy", void 0);
__decorate([
    property({ attribute: 'scroll-strategy' })
], IgcDropdownComponent.prototype, "scrollStrategy", void 0);
__decorate([
    property({ type: Boolean })
], IgcDropdownComponent.prototype, "flip", void 0);
__decorate([
    property({ type: Number })
], IgcDropdownComponent.prototype, "distance", void 0);
__decorate([
    property({ type: Boolean, attribute: 'keep-open-on-outside-click' })
], IgcDropdownComponent.prototype, "keepOpenOnOutsideClick", void 0);
__decorate([
    property({ type: Boolean, attribute: 'same-width' })
], IgcDropdownComponent.prototype, "sameWidth", void 0);
__decorate([
    watch('open')
], IgcDropdownComponent.prototype, "toggleDirectiveChange", null);
__decorate([
    watch('placement'),
    watch('flip'),
    watch('positionStrategy'),
    watch('closeOnOutsideClick'),
    watch('distance'),
    watch('sameWidth')
], IgcDropdownComponent.prototype, "updateOptions", null);
__decorate([
    watch('size')
], IgcDropdownComponent.prototype, "sizeChange", null);
__decorate([
    blazorSuppress()
], IgcDropdownComponent.prototype, "show", null);
__decorate([
    blazorSuppress()
], IgcDropdownComponent.prototype, "toggle", null);
__decorate([
    blazorSuppress()
], IgcDropdownComponent.prototype, "navigateTo", null);
__decorate([
    blazorSuppress()
], IgcDropdownComponent.prototype, "select", null);
IgcDropdownComponent = __decorate([
    themes({ bootstrap, fluent, indigo })
], IgcDropdownComponent);
export default IgcDropdownComponent;
//# sourceMappingURL=dropdown.js.map