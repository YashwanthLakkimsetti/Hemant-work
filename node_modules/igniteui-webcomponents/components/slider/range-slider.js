var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html } from 'lit';
import { property, query } from 'lit/decorators.js';
import { EventEmitterMixin } from '../common/mixins/event-emitter.js';
import { IgcSliderBaseComponent } from './slider-base.js';
export default class IgcRangeSliderComponent extends EventEmitterMixin(IgcSliderBaseComponent) {
    constructor() {
        super(...arguments);
        this._lower = 0;
        this._upper = 0;
    }
    set lower(val) {
        const oldVal = this._lower;
        this._lower = this.validateValue(val);
        this.requestUpdate('lower', oldVal);
    }
    get lower() {
        return this._lower;
    }
    set upper(val) {
        const oldVal = this._upper;
        this._upper = this.validateValue(val);
        this.requestUpdate('upper', oldVal);
    }
    get upper() {
        return this._upper;
    }
    get activeValue() {
        return this.activeThumb === this.thumbFrom ? this.lower : this.upper;
    }
    normalizeValue() {
        this._lower = this.validateValue(this._lower);
        this._upper = this.validateValue(this._upper);
    }
    getTrackStyle() {
        const toPosition = this.valueToFraction(this.upper);
        const fromPosition = this.valueToFraction(this.lower);
        const positionGap = toPosition - fromPosition;
        const filledTrackStyle = {
            width: `${positionGap * 100}%`,
            insetInlineStart: `${fromPosition * 100}%`,
        };
        return filledTrackStyle;
    }
    closestTo(goal, positions) {
        return positions.reduce((previous, current) => Math.abs(goal - current) < Math.abs(goal - previous) ? current : previous);
    }
    closestHandle(event) {
        const fromOffset = this.thumbFrom.offsetLeft + this.thumbFrom.offsetWidth / 2;
        const toOffset = this.thumbTo.offsetLeft + this.thumbTo.offsetWidth / 2;
        const xPointer = event.clientX - this.getBoundingClientRect().left;
        const match = this.closestTo(xPointer, [fromOffset, toOffset]);
        if (fromOffset === toOffset && toOffset < xPointer) {
            return this.thumbTo;
        }
        else if (fromOffset === toOffset && toOffset > xPointer) {
            return this.thumbFrom;
        }
        else if (match === fromOffset) {
            return this.thumbFrom;
        }
        else {
            return this.thumbTo;
        }
    }
    updateValue(increment) {
        const oldValue = this.activeValue;
        let lower = this.lower;
        let upper = this.upper;
        if (this.activeThumb === this.thumbFrom) {
            lower += increment;
        }
        else {
            upper += increment;
        }
        if (lower >= upper) {
            this.swapValues(lower, upper);
            this.toggleActiveThumb();
        }
        else {
            if (this.activeThumb === this.thumbFrom) {
                this.lower = lower;
            }
            else {
                this.upper = upper;
            }
        }
        if (oldValue === this.activeValue) {
            return false;
        }
        this.emitInputEvent();
        return true;
    }
    emitInputEvent() {
        this.emitEvent('igcInput', {
            detail: { lower: this.lower, upper: this.upper },
        });
    }
    emitChangeEvent() {
        this.emitEvent('igcChange', {
            detail: { lower: this.lower, upper: this.upper },
        });
    }
    swapValues(lower, upper) {
        this.lower = upper;
        this.upper = lower;
    }
    toggleActiveThumb() {
        const thumb = this.activeThumb === this.thumbFrom ? this.thumbTo : this.thumbFrom;
        thumb.focus();
    }
    renderThumbs() {
        return html `${this.renderThumb(this.lower, this.ariaLabelLower, 'thumbFrom')}
    ${this.renderThumb(this.upper, this.ariaLabelUpper, 'thumbTo')}`;
    }
}
IgcRangeSliderComponent.tagName = 'igc-range-slider';
__decorate([
    query(`#thumbFrom`)
], IgcRangeSliderComponent.prototype, "thumbFrom", void 0);
__decorate([
    query(`#thumbTo`)
], IgcRangeSliderComponent.prototype, "thumbTo", void 0);
__decorate([
    property({ type: Number })
], IgcRangeSliderComponent.prototype, "lower", null);
__decorate([
    property({ type: Number })
], IgcRangeSliderComponent.prototype, "upper", null);
__decorate([
    property({ attribute: 'aria-label-lower' })
], IgcRangeSliderComponent.prototype, "ariaLabelLower", void 0);
__decorate([
    property({ attribute: 'aria-label-upper' })
], IgcRangeSliderComponent.prototype, "ariaLabelUpper", void 0);
//# sourceMappingURL=range-slider.js.map